
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Integration Guide: Spark Streaming 3.2</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
   
  <google-codelab codelab-gaid=""
                  id="spark-streaming"
                  title="Integration Guide: Spark Streaming 3.2"
                  environment="web"
                  feedback-link="https://github.com/SolaceDev/solace-dev-codelabs/blob/master/markdown/integrations/spark-streaming">
    
      <google-codelab-step label="What you&#39;ll learn: Overview" duration="5">
        <p>This document demonstrates how to integrate Solace Java Message Service (JMS) with the Spark Streaming custom receiver for consumption of JMS messages. The goal of this document is to outline best practices for this integration to enable efficient use of both the Spark Streaming and Solace JMS.</p>
<p>The target audience of this document is developers using the Hadoopv2 with knowledge of both the Spark and JMS in general. As such this document focuses on the technical steps required to achieve the integration. For detailed background on either Solace JMS or Spark refer to the referenced documents below.</p>
<p>This document is divided into the following sections to cover the Solace JMS integration with Spark Streaming:</p>
<ul>
<li>Integrating with Spark Streaming</li>
<li>Performance Considerations</li>
<li>Working with Solace High Availability</li>
<li>Debugging Tips</li>
<li>Advanced Topics including: <ul>
<li>Authentication (LDAP example)</li>
<li>Using TLS Communication</li>
<li>Working with Solace Disaster Recovery</li>
</ul>
</li>
</ul>
<h2 is-upgraded>Related Documentation</h2>
<p>These links contain information related to this guide:</p>
<ul>
<li><a href="http://solace.dev" target="_blank">Solace Developer Portal</a></li>
<li><a href="http://docs.solace.com/Solace-JMS-API/JMS-home.htm" target="_blank">Solace Messaging API for JMS</a></li>
<li><a href="http://docs.solace.com/API-Developer-Online-Ref-Documentation/jms/index.html" target="_blank">Solace JMS API Online Reference Documentation</a></li>
<li><a href="https://docs.solace.com/Features/Core-Concepts.htm" target="_blank">Solace Feature Guide</a></li>
<li><a href="https://docs.solace.com/Solace-CLI/Using-Solace-CLI.htm" target="_blank">Solace Command Line Interface Reference</a></li>
<li><a href="https://spark.apache.org/docs/latest/streaming-custom-receivers.html" target="_blank">Spark Streaming Custom Receivers Documentation</a></li>
<li><a href="https://spark.apache.org/docs/latest/api/java/org/apache/spark/streaming/receiver/Receiver.html" target="_blank">Spark Receiver Class Documentation</a></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Get Solace Messaging" duration="10">
        <p>This tutorial requires access to Solace PubSub+ event broker and requires that you know several connectivity properties about your event broker. Specifically you need to know the following:</p>
<table>
<tr><td colspan="1" rowspan="1"><p>Resource</p>
</td><td colspan="1" rowspan="1"><p>Value</p>
</td><td colspan="1" rowspan="1"><p>Description</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Host</p>
</td><td colspan="1" rowspan="1"><p>String</p>
</td><td colspan="1" rowspan="1"><p>This is the address clients use when connecting to the event broker to send and receive messages. (Format: <code>DNS_NAME:Port</code> or <code>IP:Port</code>)</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Message VPN</p>
</td><td colspan="1" rowspan="1"><p>String</p>
</td><td colspan="1" rowspan="1"><p>The event broker Message VPN that this client should connect to. </p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Client Username</p>
</td><td colspan="1" rowspan="1"><p>String</p>
</td><td colspan="1" rowspan="1"><p>The client username. (See Notes below)</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Client Password</p>
</td><td colspan="1" rowspan="1"><p>String</p>
</td><td colspan="1" rowspan="1"><p>The client password. (See Notes below)</p>
</td></tr>
</table>
<p>There are several ways you can get access to Solace messaging and find these required properties.</p>
<h2 is-upgraded>Option 1: Use Solace Cloud</h2>
<ul>
<li>Follow <a href="https://solace.com/products/platform/cloud/" target="_blank">these instructions</a> to quickly spin up a cloud-based Solace messaging service for your applications.</li>
<li>The messaging connectivity information is found in the service details in the connectivity tab (shown below). You will need: <ul>
<li>Host:Port (use the JMS URI)</li>
<li>Message VPN</li>
<li>Client Username</li>
<li>Client Password</li>
</ul>
</li>
</ul>
<p class="image-container"><img src="img/8ffc1af5fcd5a90b.png"></p>
<h2 is-upgraded>Option 2: Start a Solace PubSub+ Software Event Broker</h2>
<ul>
<li>Follow <a href="https://solace.com/downloads/" target="_blank">these instructions</a> to start the software event broker in leading Clouds, Container Platforms or Hypervisors. The tutorials outline where to download and how to install the Solace software event broker.</li>
<li>The messaging connectivity information are the following:<ul>
<li>Host: &lt;public_ip&gt; (IP address assigned to the software event broker in tutorial instructions)</li>
<li>Message VPN: default</li>
<li>Client Username: sampleUser (can be any value)</li>
<li>Client Password: samplePassword (can be any value)</li>
</ul>
Note: By default, the Solace software event broker &#34;default&#34; message VPN has authentication disabled.</li>
</ul>
<h2 is-upgraded>Option 3: Get access to a Solace PubSub+ appliance</h2>
<ul>
<li>Contact your Solace PubSub+ appliance administrators and obtain the following: <ul>
<li>A Solace Message-VPN where you can produce and consume direct and persistent messages</li>
<li>The host name or IP address of the appliance hosting your Message-VPN</li>
<li>A username and password to access the appliance</li>
</ul>
</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Integrating with Spark Streaming" duration="25">
        <p>The general Spark Streaming support for custom receivers is documented in the <a href="https://spark.apache.org/docs/latest/streaming-custom-receivers.html" target="_blank">Spark Streaming Custom Receivers Documentation</a>. The configuration outlined in this document makes use of a custom receiver to achieve the desired integration with Solace.</p>
<p>This integration guide demonstrates how to configure a Spark Streaming application to receive JMS messages using a custom receiver. The following steps are required to accomplish this:</p>
<ul>
<li>Step 1 – Configuring the Solace PubSub+ event broker</li>
<li>Step 2 – Coding a JMS custom receiver</li>
<li>Step 3 – Deploying JMS receiver</li>
</ul>
<h2 is-upgraded>Description of Resources Required</h2>
<p>This integration guide will demonstrate creation of Solace JMS custom receiver and configuring the receiver to receive messages. This section outlines the resources that are required/created and used in the subsequent sections.</p>
<h3 is-upgraded>Solace Resources</h3>
<p>The following event broker resources are required for the integration sample in this document.</p>
<table>
<tr><td colspan="1" rowspan="1"><p>Resource</p>
</td><td colspan="1" rowspan="1"><p>Value</p>
</td><td colspan="1" rowspan="1"><p>Description</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Event Broker Host</p>
</td><td colspan="2" rowspan="4"><p>Refer to step Get Solace Messaging  for values</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Message VPN</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Client Username</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Client Password</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Solace Queue</p>
</td><td colspan="1" rowspan="1"><p>Q/requests</p>
</td><td colspan="1" rowspan="1"><p>Solace destination of messages produced and consumed </p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>JNDI Connection Factory</p>
</td><td colspan="1" rowspan="1"><p>JNDI/CF/spring</p>
</td><td colspan="1" rowspan="1"><p>The JNDI Connection factory for controlling Solace JMS connection properties</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>JNDI Queue Name</p>
</td><td colspan="1" rowspan="1"><p>JNDI/Q/requests</p>
</td><td colspan="1" rowspan="1"><p>The JNDI name of the queue used in the samples</p>
</td></tr>
</table>
<h3 is-upgraded>Spark Resources</h3>
<p>The following Spark resources are required for code integration:</p>
<table>
<tr><td colspan="1" rowspan="1"><p>Resource</p>
</td><td colspan="1" rowspan="1"><p>Description</p>
</td></tr>
<tr><td colspan="2" rowspan="1"><p>org.apache.spark.storage.StorageLevel</p>
</td><td colspan="1" rowspan="1"></td></tr>
<tr><td colspan="1" rowspan="1"><p>org.apache.spark.streaming.receiver.Receiver</p>
</td><td colspan="1" rowspan="1"><p>Class implementing Receiver</p>
</td></tr>
</table>
<h2 is-upgraded>Step 1 – Configuring the Solace Event Broker</h2>
<p>The Solace event broker needs to be configured with the following configuration objects at a minimum to enable JMS to send and receive messages within the Spark application.</p>
<ul>
<li>A Message VPN, or virtual event broker, to scope the integration on the Solace event broker.</li>
<li>Client connectivity configurations like usernames and profiles</li>
<li>Guaranteed messaging endpoints for receiving and sending messages.</li>
<li>Appropriate JNDI mappings enabling JMS clients to connect to the Solace event broker configuration.</li>
</ul>
<p>The recommended approach for configuring a event broker is using <a href="https://docs.solace.com/Solace-PubSub-Manager/PubSub-Manager-Overview.htm" target="_blank">Solace PubSub+ Manager</a>, Solace&#39;s browser-based administration console packaged with the Solace PubSub+ event broker. This document uses CLI as the reference to remain concise - look for related settings if using Solace PubSub+ Manager.</p>
<p>For more details related to event broker CLI see <a href="https://docs.solace.com/Solace-CLI/Using-Solace-CLI.htm" target="_blank">Solace-CLI</a>. Wherever possible, default values will be used to minimize the required configuration. The CLI commands listed also assume that the CLI user has a Global Access Level set to Admin. For details on CLI access levels please see <a href="https://docs.solace.com/Configuring-and-Managing/CLI-User-Access-Levels.htm?Highlight=cli%20access%20level" target="_blank">User Authentication and Authorization</a>.</p>
<h3 is-upgraded>Creating a Message VPN</h3>
<p>If you are using Solace Cloud you can skip this step because a message-VPN is already assigned. For the name, refer to the &#34;Message VPN&#34; in the connection details page.</p>
<p>This section outlines how to create a message-VPN called &#34;Solace_Spring_VPN&#34; on the event broker with authentication disabled and 2GB of message spool quota for Guaranteed Messaging. This message-VPN name is required in the configuration when connecting to the messaging event broker. In practice, appropriate values for authentication, message spool and other message-VPN properties should be chosen depending on the end application&#39;s use case.</p>
<pre><code>&gt; home
&gt; enable
# configure
(config)# create message-vpn Solace_Spring_VPN
(config-msg-vpn)# authentication
(config-msg-vpn-auth)# user-class client
(config-msg-vpn-auth-user-class)# basic auth-type none
(config-msg-vpn-auth-user-class)# exit
(config-msg-vpn-auth)# exit
(config-msg-vpn)# no shutdown
(config-msg-vpn)# exit
(config)#
(config)# message-spool message-vpn Solace_Spring_VPN
(config-message-spool)# max-spool-usage 2000
(config-message-spool)# exit
(config)#
</code></pre>
<h3 is-upgraded>Configuring Client Usernames &amp; Profiles</h3>
<p>This section outlines how to update the default client-profile and how to create a client username for connecting to the Solace event broker. For the client-profile, it is important to enable guaranteed messaging for JMS messaging and transacted sessions if using transactions.</p>
<p>The chosen client username of &#34;spark_user&#34; will be required by the Spark application when connecting to the Solace event broker.</p>
<pre><code>(config)# client-profile default message-vpn Solace_Spark_VPN
(config-client-profile)# message-spool allow-guaranteed-message-receive
(config-client-profile)# message-spool allow-guaranteed-message-send
(config-client-profile)# message-spool allow-transacted-sessions
(config-client-profile)# exit
(config)#
(config)# create client-username spark_user message-vpn Solace_Spark_VPN
(config-client-username)# acl-profile default 
(config-client-username)# client-profile default
(config-client-username)# no shutdown
(config-client-username)# exit
(config)#
</code></pre>
<h3 is-upgraded>Setting up Guaranteed Messaging Endpoints</h3>
<p>This integration guide shows receiving messages within the Spark application from a single JMS Queue. For illustration purposes, this queue is chosen to be an exclusive PubSub+ queue with a message spool quota of 2GB matching quota associated with the message VPN. The queue name chosen is &#34;Q/requests&#34;.</p>
<pre><code>(config)# message-spool message-vpn Solace_Spark_VPN
(config-message-spool)# create queue Q/receive
(config-message-spool-queue)# access-type exclusive
(config-message-spool-queue)# max-spool-usage 2000
(config-message-spool-queue)# permission all delete
(config-message-spool-queue)# no shutdown
(config-message-spool-queue)# exit
(config-message-spool)# exit
(config)#
</code></pre>
<h3 is-upgraded>Setting up Solace JNDI References</h3>
<p>To enable the JMS clients to connect and look up the Queue destination required by Spark, there are two JNDI objects required on the Solace  event broker:</p>
<ul>
<li>A connection factory: JNDI/Sol/CF <ul>
<li>Note: Ensure <code>direct-transport</code> is disabled for JMS persistent messaging</li>
</ul>
</li>
<li>A queue destination: JNDI/Q/receive</li>
</ul>
<p>They are configured as follows:</p>
<pre><code>(config)# jndi message-vpn Solace_Spark_VPN
(config-jndi)# create connection-factory JNDI/Sol/CF
(config-jndi-connection-factory)# property-list messaging-properties
(config-jndi-connection-factory-pl)# property default-delivery-mode persistent
(config-jndi-connection-factory-pl)# exit
(config-jndi-connection-factory)# property-list transport-properties
(config-jndi-connection-factory-pl)# property direct-transport false
(config-jndi-connection-factory-pl)# exit
(config-jndi-connection-factory)# exit
(config-jndi)#
(config-jndi)# create queue JNDI/Q/receive
(config-jndi-queue)# property physical-name Q/receive
(config-jndi-queue)# exit
(config-jndi)# 
(config-jndi)# no shutdown
(config-jndi)# exit
(config)#
</code></pre>
<h2 is-upgraded>Step 2 – Coding a JMS custom receiver</h2>
<p>From <a href="https://spark.apache.org/docs/latest/api/java/org/apache/spark/streaming/receiver/Receiver.html" target="_blank">Spark Receiver Class Documentation</a> there is details on how to build a custom receiver and a template. We will use this template and build a <code>PubSubPlusJMSReceiver</code>, which will stream events from the PubSub+ event broker through a JMS connection, using JNDI lookup of the queue to receive from.</p>
<p>The <code>PubSubPlusJMSReceiver</code> extends the <code>org.apache.spark.streaming.receiver.Receiver</code> and implements the <code>javax.jms.MessageListener</code>.  This will result in the following methods created:</p>
<ul>
<li><code>PubSubPlusJMSReceiver</code> constructor – Synchronously called once as the Receiver is initially created.</li>
<li><code>org.apache.spark.streaming.receiver.Receiver.onStart()</code> – Asynchronously called once as the Receiver is started.</li>
<li><code>org.apache.spark.streaming.receiver.Receiver.onStop()</code> – Asynchronously called once as the Receiver is stopped</li>
<li><code>javax.jms.MessageListener.onMessage()</code> – Asynchronously called on every message received from Solace</li>
</ul>
<pre><code language="language-Java" class="language-Java">public class PubSubPlusJMSReceiver extends Receiver&lt;String&gt; implements MessageListener {
  private static final long serialVersionUID = 1L;
  private static final String SOLJMS_INITIAL_CONTEXT_FACTORY =
              &#34;com.solacesystems.jndi.SolJNDIInitialContextFactory&#34;;

  public JMSReceiver( ) {
    super(StorageLevel.MEMORY_ONLY_SER_2());
  }

  @Override
  public void onStart() {
    // TODO Auto-generated from spark.streaming.receiver
  }

  @Override
  public void onStop() {
    // TODO Auto-generated from spark.streaming.receiver
  }

  @Override
  public void onMessage(Message arg0) {
    // TODO Auto-generated from javax.jms.MessageListener 
  }
}
</code></pre>
<p>In the constructor we need to collect information to information needed to connect to Solace and build the JMS environment.</p>
<pre><code language="language-Java" class="language-Java">public PubSubPlusJMSReceiver(String brokerURL,
                             String vpn,
                             String username,
                             String password,
                             String jndiQueueName,
                             String jndiConnectionFactory,
                             StorageLevel storageLevel)
{
  super(storageLevel);
  _brokerURL = brokerURL;
  _vpn = vpn;
  _username = username;
  _password = password;
  _queueName = jndiQueueName;
  _connectionFactory = jndiConnectionFactory;
}
</code></pre>
<p>Next, in the <code>onStart()</code> method we need to look up the JMS connection factory and queue then connect to receive messages:</p>
<pre><code language="language-Java" class="language-Java">@Override
public void onStart()
{
  log.info(&#34;Starting up...&#34;);
  try
  {
    Hashtable&lt;String, String&gt; env = new Hashtable&lt;String, String&gt;();
    env.put(InitialContext.INITIAL_CONTEXT_FACTORY,
                  SOLJMS_INITIAL_CONTEXT_FACTORY);
    env.put(InitialContext.PROVIDER_URL, _brokerURL);
    env.put(Context.SECURITY_PRINCIPAL, _username);
    env.put(Context.SECURITY_CREDENTIALS, _password);
    env.put(SupportedProperty.SOLACE_JMS_VPN, _vpn);
    javax.naming.Context context = new javax.naming.InitialContext(env);
    ConnectionFactory factory = (ConnectionFactory) context.lookup(_connectionFactory);
    Destination queue = (Destination) context.lookup(_queueName);
    _connection = factory.createConnection();
    _connection.setExceptionListener(new JMSReceiverExceptionListener());
    Session session = _connection.createSession(false,
        Session.CLIENT_ACKNOWLEDGE);

    MessageConsumer consumer;
    consumer = session.createConsumer(queue);
    consumer.setMessageListener(this);
    _connection.start();
    log.info(&#34;Completed startup.&#34;);
  } catch (Exception ex) {
    // Caught exception, try a restart
    log.error(&#34;Callback onStart caught exception, restarting &#34;, ex);
    restart(&#34;Callback onStart caught exception, restarting &#34;, ex);
  }
}
</code></pre>
<p>Finally, when receiving messages from the PubSub+ broker they need to be stored into Spark:</p>
<pre><code language="language-Java" class="language-Java">@Override
public void onMessage(Message message) {
  log.info(&#34;Callback onMessage received&#34; + message);
  store(message.toString());
  try {
    message.acknowledge();
  } catch (JMSException ex) {
    log.error(&#34;Callback onMessage failed to ack message&#34;, ex);
  }
}
</code></pre>
<h2 is-upgraded>Step 3 – Deploying JMS Receiver</h2>
<p>This section will demo the use of the JMS receiver by creating a Java Spark Streaming example program, which counts the words in the input stream from the JMS receiver. For details of how the example works refer to the Java version of the <a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html#a-quick-example" target="_blank">Spark Streaming Quick Example documentation</a>, which demonstrates a similar use case.</p>
<p>Following code snippet shows how <code>PubSubPlusJMSReceiver</code> is invoked:</p>
<pre><code language="language-Java" class="language-Java">public static void main(String[] args) throws Exception {
  // Create the context with a 1 second batch size
  SparkConf sparkConf = new SparkConf().setAppName(&#34;JavaCustomReceiver&#34;);
  JavaStreamingContext ssc = new JavaStreamingContext(sparkConf, new Duration(1000));
  // Create a input stream with the custom receiver on provided PubSub+ broker connection config
  JavaReceiverInputDStream&lt;String&gt; lines = ssc.receiverStream(
      new PubSubPlusJMSReceiver(args[0], args[1], args[2], args[3], args[4], args[5],
                                StorageLevel.MEMORY_ONLY_SER_2()));
  ...
}
</code></pre>
<h3 is-upgraded>Demo pre-requisites</h3>
<ul>
<li>Working Spark deployment: this can be a cluster of Spark machines or a standalone local installation.</li>
<li>Working and configured Solace PubSub+ deployment - refer to the previous sections.</li>
</ul>
<h3 is-upgraded>Demo run</h3>
<p>The demo code shall be first built, then submitted to Spark. Within a cluster of Spark machines you can build and submit jobs from any machine. For simplicity, a local Spark installation is assumed here.</p>
<ol type="1">
<li>Clone this project from GitHub</li>
</ol>
<pre><code language="language-bash" class="language-bash">git clone https://github.com/SolaceLabs/solace-integration-guides.git
cd solace-integration-guides/src/spark-streaming
export PROJECT_HOME=$(pwd)
</code></pre>
<ol type="1">
<li>Build the demo</li>
</ol>
<pre><code language="language-bash" class="language-bash">mvn package
# this will generate jar libraries
# note the jar variant that includes required dependencies
ls target/*.jar
</code></pre>
<ol type="1">
<li>Submit to Spark</li>
</ol>
<pre><code language="language-bash" class="language-bash"># Substitute &#34;/path/to/spark&#34; to local Spark install directory
export SPARK_HOME=&#34;/path/to/spark&#34;
# Substitute from the configuration described in the Solace Resources section
export HOST=&#34; &lt;Solace Event Broker Host&gt;&#34;
export MESSAGE_VPN=&#34;&lt;Message VPN&gt;&#34;
export USERNAME=&#34;&lt;Client Username&gt;&#34;
export PASSWORD=&#34;&lt;Client Password&gt;&#34;
export JNDI_QUEUE=&#34;&lt;JNDI Queue Name&gt;&#34;
export JNDI_CF=&#34;&lt;JNDI Connection Factory&gt;&#34;
# This example configures 4 local threads in the --master parameter
$SPARK_HOME/bin/spark-submit \
  --class com.solace.sample.PubSubPlusJMSReceiverTest \
  --master local[4] \
  $PROJECT_HOME/target/pubsubplus-jms-to-spark-streaming-demo-0.0.1-jar-with-dependencies.jar \
  $HOST \
  $MESSAGE_VPN \
  $USERNAME \
  $PASSWORD \
  $JNDI_QUEUE \
  $JNDI_CF
</code></pre>
<ol type="1">
<li>Send test messages to the PubSub+ queue, which will be streamed to Spark, then observe the logs. You can send individual messages from the <a href="https://docs.solace.com/Broker-Manager/PubSub-Manager-Overview.htm?Highlight=Try%20Me#Test-Messages" target="_blank">Try Me!</a> tab of the PubSub+ Broker Manager. To generate larger number of messages it is recommended to use the <a href="https://docs.solace.com/SDKPerf/SDKPerf.htm" target="_blank">SDKPerf tool</a>.</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="Performance Considerations" duration="5">
        <p>In the provided example above persistent messaging was used on the  event broker and the Spark Streaming client connected to a queue. This design pattern provides the highest level of reliability as each message is persisted on the Solace Event Broker and will not be lost in case of a client failure. This message pattern consumes the most resources on the Solace Event Broker and is not the most performant.</p>
<p>If the client does not want to receive messages that where missed while it was offline, does not want to receive older messages if it is unable to keep up to the published message flow, or wants the highest throughput with lowest latency; then direct messaging is the recommended pattern.</p>
<p>To achieve direct messaging, configure the connection-factory to enable this feature.</p>
<pre><code>(config)# jndi message-vpn Solace_Spark_VPN
(config-jndi)# connection-factory JNDI/Sol/CF
(config-jndi-connection-factory)# property-list transport-properties
(config-jndi-connection-factory-pl)# property direct-transport true

(config)# jndi message-vpn Solace_Spark_VPN
(config-jndi)# create topic JNDI/T/receive
(config-jndi-queue)# property physical-name T/receive
(config-jndi-queue)# exit
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Working with Solace High Availability (HA)" duration="5">
        <p>The <a href="https://docs.solace.com/Solace-JMS-API/JMS-Intro.htm" target="_blank">Developer Guide for Solace JMS API</a> section &#34;Establishing Connections&#34; and &#34;Managing Sessions&#34; provides details on how to enable the Solace JMS connection to automatically reconnect to the standby event broker in the case of a HA failover of a event broker. By default Solace JMS connections will reconnect to the standby event broker in the case of an HA failover.</p>
<p>Note: When using HA redundant event brokers, a fail-over from one event broker to its mate will typically occur in less than 30 seconds, however, applications should attempt to reconnect for at least five minutes.</p>
<p>In <a href="https://docs.solace.com/Configuring-and-Managing/Configuring-JNDI-Objects.htm" target="_blank">Configuring JNDI Objects</a>, the Solace CLI commands correctly configured the required JNDI properties to reasonable values. Note: the retry parameters re all defaults, these commands are repeated here for completeness.</p>
<pre><code>(config)# jndi message-vpn solace_VPN
(config-jndi)# create connection-factory JNDI/Sol/CF
(config-jndi-connection-factory)# property-list transport-properties
(config-jndi-connection-factory-pl)# property &#34;reconnect-retry-wait&#34; &#34;3000&#34;
(config-jndi-connection-factory-pl)# property &#34;reconnect-retries&#34; &#34;20&#34;
(config-jndi-connection-factory-pl)# property &#34;connect-retries-per-host&#34; &#34;5&#34;
(config-jndi-connection-factory-pl)# property &#34;connect-retries&#34; &#34;1&#34;
(config-jndi-connection-factory-pl)# exit
(config-jndi-connection-factory)# exit
(config-jndi)# exit
(config)#
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Debugging Tips for Solace JMS API Integration" duration="5">
        <p>The key component for debugging integration issues with the Solace JMS API is to enable API logging. Spark was written using Jakarta Commons Logging API (JCL), Solace JMS API also makes use of the Jakarta Commons Logging API (JCL), configuring the Solace JMS API logging is very similar to configuring any other Spark application. The following example shows how to enable debug logging in the Solace JMS API using log4j. One note to consider is that since the Solace JMS API has a dependency on the Solace Java API (JCSMP) both of the following logging components should be enabled and tuned when debugging to get full information. By default info logs will be written to the consol. Following example sets both to debug level:</p>
<pre><code>log4j.category.com.solacesystems.jms=DEBUG
log4j.category.com.solacesystems.jcsmp=DEBUG
</code></pre>
<p>Above lines can be added to the <code>log4j.properties</code> configuration file located at the <code>$SPARK_HOME/conf</code> directory. Note: if no <code>log4j.properties</code> configuration file exists then the contents of the <code>log4j.properties.template</code> file can be used as a starting point. With this you can get output in a format similar to the following which can help in understanding what is happening within the Solace JMS API.</p>
<pre><code language="language-log" class="language-log">22/01/31 09:11:22 INFO TcpClientChannel: Client-2: Connecting to host &#39;orig=tcps://mr-xyz.messaging.solace.cloud:55443, scheme=tcps://, host=mr-xyz.messaging.solace.cloud, port=55443&#39; (host 1 of 1, smfclient 2, attempt 1 of 1, this_host_attempt: 1 of 1)
22/01/31 09:11:22 INFO SNIUtil: Server Name Indication (SNI) automatically applied by using provided hostname
22/01/31 09:11:22 INFO SSLSmfClient: SSLEngine Supported Protocols: [SSLV3, TLSV1, TLSV1.1, TLSV1.2]
22/01/31 09:11:22 INFO SSLSmfClient: Application Specified Protocols: [SSLv3, TLSv1, TLSv1.1, TLSv1.2]
22/01/31 09:11:22 INFO TcpClientChannel: Client-2: Connected to host &#39;orig=tcps://mr-xyz.messaging.solace.cloud:55443, scheme=tcps://, host=mr-xyz.messaging.solace.cloud, port=55443&#39; (smfclient 2)
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Advanced Topics" duration="25">
        <h2 is-upgraded>Authentication (LDAP example)<a name="authentication-ldap-example" target="_blank"></a></h2>
<p>JMS Client authentication is handled by the PubSub+ event broker. The broker supports a variety of authentications schemes as described in <a href="https://docs.solace.com/Configuring-and-Managing/Configuring-Client-Authentication.htm" target="_blank">the Solace documentation</a>. In this section we will show how to configure the PubSub+ Event Broker to pass the authentication username/password through to an LDAP,(Active-Directory) server to incorporate with enterprise level authentication mechanisms.  TLS client certificate, OAuth and Kerberos are also possible.</p>
<ul>
<li>First an LDAP profile needs to be created, this includes:</li>
<li>Admin Username and Password to do LDAP lookups</li>
<li>Part of the LDAP structure to check for users</li>
<li>Location of LDAP server(s)</li>
<li>Search filter, how to compare Client Username to LDAP Structure.</li>
</ul>
<pre><code>(config)# create authentication ldap-profile ActiveDirectoryIntegration
(config/authentication/ldap-profile)# admin dn DomainAdmin password xxxxxx
(config/authentication/ldap-profile)# search base-dn dc=lab,dc=solace,dc=com
(config/authentication/ldap-profile)# ldap-server ldap://192.168.1.56 index 1
(config/authentication/ldap-profile)# search filter &#34;(sAMAccountName = $CLIENT_USERNAME)&#34;
(config/authentication/ldap-profile)# no shut
(config/authentication/ldap-profile)# exit
</code></pre>
<p>Finally the LDAP profile will need to be enabled for the message VPN.  Note that there is no code change from the Application/API.  As the authentication is pass-through from the  event broker to the LDAP server.</p>
<pre><code>(config)# message-vpn Solace_Spark_VPN
(config/message-vpn)# authentication user-class client
(...message-vpn/authentication/user-class)# basic
(...e-vpn/authentication/user-class/basic)# auth-type ldap ActiveDirectoryIntegration
(...e-vpn/authentication/user-class/basic)# exit
</code></pre>
<h2 is-upgraded>Enabling TLS on the PubSub+ Event Broker<a name="using-tls-communication" target="_blank"></a></h2>
<p>TLS may already be enabled on your Event Broker, for example if using PubSub+ Cloud. In this case you can skip this section.</p>
<p>To enable secure connections (TLS) to the Solace event broker, the following configuration must be updated on the Solace event broker.</p>
<ul>
<li>Server Certificate</li>
<li>TLS/SSL Service Listen Port</li>
<li>Enable TLS/SSL over SMF in the Message VPN</li>
</ul>
<p>The following sections outline how to configure these items.</p>
<h4 is-upgraded>Configuring the Server Certificate</h4>
<p>Before starting, here is some background information on the server certificate required by the event broker. This is from the <a href="https://docs.solace.com/Configuring-and-Managing/Managing-Server-Certs.htm" target="_blank">Solace documentation</a>:</p>
<p>&#34;To enable TLS/SSL-encryption, you must set the TLS/SSL server certificate file that the Solace PubSub+ event broker is to use. This server certificate is presented to clients during TLS/SSL handshakes. The server certificate must be an x509v3 certificate and include a private key. The server certificate and key use an RSA algorithm for private key generation, encryption and decryption, and they both must be encoded with a Privacy Enhanced Mail (PEM) format.&#34;</p>
<p>To configure the server certificate, first copy the server certificate to the Solace event broker. For the purposes of this example, assume the server certificate file is named &#34;mycert.pem&#34;.</p>
<pre><code># copy sftp://[&lt;username&gt;@]&lt;ip-addr&gt;/&lt;remote-pathname&gt;/mycert.pem /certs
&lt;username&gt;@&lt;ip-addr&gt;&#39;s password:
#
</code></pre>
<p>Then set the server certificate for the Solace event broker.</p>
<pre><code>(config)# ssl server-certificate mycert.pem
(config)#
</code></pre>
<h4 is-upgraded>Configure TLS/SSL Service Listen Port</h4>
<p>By default, the Solace event broker accepts secure messaging client connections on port 55443. If this port is acceptable then no further configuration is required and this section can be skipped. If a non-default port is desired, then follow the steps below. Note this configuration change will disrupt service to all clients of the Solace event broker and should therefore be performed during a maintenance window when this client disconnection is acceptable. This example assumes that the new port should be 55403.</p>
<pre><code>(config)# service smf
(config-service-smf)# shutdown
All SMF and WEB clients will be disconnected.
Do you want to continue (y/n)? y
(config-service-smf)# listen-port 55403 ssl
(config-service-smf)# no shutdown
(config-service-smf)# exit
(config)#
</code></pre>
<h4 is-upgraded>Enable TLS/SSL within the Message VPN</h4>
<p>By default within Solace message VPNs both the plain-text and SSL services are enabled. If the Message VPN defaults remain unchanged, then this section can be skipped. However, if within the current application VPN, this service has been disabled, then for secure communication to succeed it should be enabled. The steps below show how to enable SSL within the messaging (SMF) service to allow secure client connections from the Spark Streaming client.</p>
<pre><code>(config)# message-vpn solace_VPN
(config-msg-vpn)# service smf
(config-msg-vpn-service-smf)# ssl
(config-msg-vpn-service-ssl)# no shutdown
(config-msg-vpn-service-ssl)# exit
(config-msg-vpn-service-smf)# exit
(config-msg-vpn-service)# exit
(config-msg-vpn)# exit
(config)#
</code></pre>
<h2 is-upgraded>Configuring Secure Connections on the Spark Client</h2>
<h4 is-upgraded>Updating the provider URL</h4>
<p>In order to signal to the PubSub+ JMS API that the connection should be a secure connection, the protocol must be updated in &#34;Solace Event Broker Host&#34;:</p>
<pre><code>tcps://&lt;host&gt;:&lt;port&gt;
</code></pre>
<h4 is-upgraded>Adding SSL Related Configuration</h4>
<p>Additionally, if using a self-signed server certificate, the Solace JMS API must be able to validate the server certificate of the Solace Event Broker in order to establish a secure connection. To do this, the following trust store parameters need to be provided in the jndi.properties file:</p>
<p>First the Solace JMS API must be given a location of a trust store file so that it can verify the credentials of the Solace Event Broker server certificate during connection establishment. This parameter takes a URL or Path to the trust store file.</p>
<pre><code>env.put(SupportedProperty.Solace_JMS_SSL_TrustStore, ___Path_or_URL___)
</code></pre>
<p>It is also required to provide a trust store password. This password allows the Solace JMS API to validate the integrity of the contents of the trust store. This is done through the following parameter.</p>
<pre><code>env.put(SupportedProperty.Solace_JMS_SSL_TrustStorePassword, ___Password___)
</code></pre>
<p>There are multiple formats for the trust store file. By default Solace JMS assumes a format of Java Key Store (JKS). So if the trust store file follows the JKS format then this parameter may be omitted. Solace JMS supports two formats for the trust store: &#34;jks&#34; for Java Key Store or &#34;pkcs12&#34;. Setting the trust store format is done through the following parameter.</p>
<pre><code>env.put(SupportedProperty.Solace_JMS_SSL_TrustStoreFormat, jks)
</code></pre>
<p>And finally, the authentication scheme must be selected. Solace JMS supports the following authentication schemes for secure connections:</p>
<ul>
<li>AUTHENTICATION_SCHEME_BASIC</li>
<li>AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE</li>
</ul>
<p>This integration example will use basic authentication. So the required parameter is as follows:</p>
<pre><code>env.put(SupportedProperty.Solace_JMS_Authentication_Scheme,AUTHENTICATION_SCHEME_BASIC)
</code></pre>
<h2 is-upgraded>Working with Solace Disaster Recovery<a name="working-with-solace-disaster-recovery" target="_blank"></a></h2>
<p>The [Solace-FG] section &#34;Data Center Replication&#34; contains a sub-section on &#34;Application Implementation&#34; which details items that need to be considered when working with Solace&#34;s Data Center Replication feature. This integration guide will show how the following items required to have a Spark Streaming client successfully connect to a backup data center using the Solace Data Center Replication feature.</p>
<ul>
<li>Configuring a Host List within the Spark Streaming client</li>
<li>Configuring JMS Reconnection Properties within Solace JNDI</li>
<li>Configuring Message Driven Bean Re-activation in the Event of Activation Failures</li>
<li>Disaster Recovery Behavior Notes</li>
</ul>
<h3 is-upgraded>Configuring a Host List within the Spark Streaming client</h3>
<p>As described in [Solace-Docs], the host list provides the address of the backup data center. This is configured within the Spark Streaming client through the ConnectionURL configuration property value (of a respective JCA entity) as follows:</p>
<pre><code>tcp://__IP_active_site:PORT__,tcp://__IP_standby_site:PORT__
</code></pre>
<p>The active site and standby site addresses are provided as a comma-separated list of &#34;Connection URIs&#34;.  When connecting, the Solace JMS connection will first try the active site and if it is unable to successfully connect to the active site, then it will try the standby site. This is discussed in much more detail in the referenced Solace documentation</p>
<h3 is-upgraded>Configuring reasonable JMS Reconnection Properties within Solace JNDI</h3>
<p>In order to enable applications to successfully reconnect to the standby site in the event of a data center failure, it is required that the Solace JMS connection be configured to attempt connection reconnection for a sufficiently long time to enable the manual switch-over to occur. This time is application specific depending on individual disaster recovery procedures and can range from minutes to hours depending on the application. In general it is best to tune the reconnection by changing the &#34;reconnect retries&#34; parameter within the Solace JNDI to a value large enough to cover the maximum time to detect and execute a disaster recovery switch over. If this time is unknown, it is also possible to use a value of &#34;-1&#34; to force the Solace JMS API to reconnect indefinitely.</p>
<p>The reconnect retries is tuned in the Solace event broker CLI as follows:</p>
<pre><code>config)# jndi message-vpn solace_VPN
(config-jndi)# connection-factory JNDI/Sol/CF
(config-jndi-connection-factory)# property-list transport-properties
(config-jndi-connection-factory-pl)# property &#34;reconnect-retries&#34; &#34;-1&#34;
(config-jndi-connection-factory-pl)# exit
(config-jndi-connection-factory)# exit
(config-jndi)# exit
(config)#
</code></pre>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
