
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Be Real-Time: Design, Document, Discover and Develop Event-Driven APIs</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
   
  <google-codelab codelab-gaid=""
                  id="design-document-discover-develop-event-driven-apis"
                  title="Be Real-Time: Design, Document, Discover and Develop Event-Driven APIs"
                  environment="web"
                  feedback-link="https://github.com/SolaceDev/solace-dev-codelabs/blob/master/markdown/design-document-discover-develop-event-driven-apis">
    
      <google-codelab-step label="What you&#39;ll learn" duration="1">
        <aside class="warning"><p><strong>Note that this Codelab uses Event Portal v1 which has been deprecated in favor of Event Portal v2. Please use the in-app samples, </strong><a href="https://training.solace.com/learn/course/external/view/elearning/373/pubsub-cloud-event-portal-fundamentals" target="_blank"><strong>PubSub+ Cloud Event Portal Fundamentals</strong></a><strong> course, and the </strong><a href="https://docs.solace.com/Cloud/Event-Portal/event-portal-lp.htm" target="_blank"><strong>Solace Docs</strong></a><strong> to get started.</strong></p>
</aside>
<p>Most organizations are adopting an event-driven architecture (EDA) to compete in a world where customer satisfaction requires real-time outcomes.</p>
<p>In this code lab we&#39;ll build and expand your toolbox by learning how an Event Portal, paired with industry standard specifications and frameworks, enable a smooth journey to bring your EDA from initial architecture and design to code running in production while also setting your team up for success as the business needs, architecture and applications themselves are enhanced over time.</p>
<p>Throughout this workshop we will get hands on and talk about:</p>
<p>PubSub+ Event Portal</p>
<ul>
<li>Architect, Design and extend an EDA which includes multiple Applications, Events, and Schemas.</li>
<li>Document Applications, Events, and Schemas along with best practices for documentation</li>
<li>Use the Event Catalog and Designer to Learn, Understand and Ideate</li>
</ul>
<p>AsyncAPI</p>
<ul>
<li>AsyncAPI is an open initiative for defining asynchronous APIs, providing a specification, and tooling such as code generation.</li>
<li>Use the AsyncAPI Generator to generate skeleton code and object models for event-driven microservices</li>
</ul>
<aside class="special"><p> Artifacts created or used throughout this codelab can be found in <a href="https://github.com/Mrc0113/ep-design-workshop" target="_blank">this Github repo</a></p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="What you need: Prerequisites" duration="2">
        <p>üõ† This page covers the setup needed to perform this codelab. üõ†</p>
<h2 is-upgraded>AsyncAPI Generator Requirements</h2>
<p>‚úÖ Install instructions available <a href="https://github.com/asyncapi/generator#requirements" target="_blank">here</a></p>
<ul>
<li>Node.js v14.16+ (Check version using <code>node -v</code>)</li>
<li>npm v6.13.7+ (Check version using <code>npm -version</code>)</li>
</ul>
<p>We&#39;ll install the generator itself later üëç</p>
<h2 is-upgraded>Java / Spring Cloud Stream Requirements</h2>
<p>‚úÖ Spring Cloud Stream just requires Java and Maven to use üöÄ</p>
<ul>
<li>Java 1.8+ (Check version using <code>java -version</code>)</li>
<li>Maven 3.3+ (Check version using <code>mvn -version</code>) <ul>
<li>On mac you can <code>brew install maven</code></li>
<li>Other install instructions <a href="https://maven.apache.org/install.html" target="_blank">here</a></li>
</ul>
</li>
<li>Your favorite Java IDE üí•</li>
</ul>
<h2 is-upgraded>Node.js Requirements</h2>
<p>‚úÖ There are only a few requirements for the Node.js steps!</p>
<ul>
<li>Node version &gt;= v14.16.1 Check version using <code>node -v</code>)</li>
<li>Your favorite Editor</li>
</ul>
<h2 is-upgraded>PubSub+ Event Broker Connection Info</h2>
<p>‚úÖ The credentials below are for a public event feed found on the <a href="http://solace.dev/marketplace" target="_blank">Solace feed Marketplace</a> that we&#39;ll use during this codelab.</p>
<ul>
<li>SMF Host: <code>tcp://taxi.messaging.solace.cloud:55555</code></li>
<li>MQTT Host: <code>mqtt://taxi.messaging.solace.cloud:8883</code></li>
<li>Message VPN: <code>nyc-modern-taxi</code></li>
<li>Username: <code>public-taxi-user</code></li>
<li>Password: <code>iliketaxis</code></li>
</ul>
<p>‚úÖ Note that this client-username has permissions to subscribe to <code>taxinyc/></code> and <code>test/taxinyc/></code> and permissions to publish to <code>test/taxinyc/></code></p>


      </google-codelab-step>
    
      <google-codelab-step label="Prepare PubSub&#43; Event Portal" duration="6">
        <h3 is-upgraded>Sign-up for Solace Cloud</h3>
<p>‚úÖ If you already have a Solace Cloud account just login, otherwise please sign-up for a free Solace Cloud Account using <a href="https://bit.ly/try-solace-free" target="_blank">this link</a>. Note that no credit card is required. You will receive an email to activate the account and will then be prompted to start the free trial.</p>
<p class="image-container"><img alt="sc_trial" src="img/c2ffd601be37f2ea.png"></p>
<h3 is-upgraded>Import Existing Designed EDA</h3>
<p>‚úÖ Download the Application Domain export file: <a href="https://github.com/Mrc0113/ep-design-workshop/blob/main/EventPortalExport_Initial.json" target="_blank">EventPortalExport_Initial.json</a></p>
<p>You can download the file via curl or by cloning the git repo</p>
<pre><code language="language-bash" class="language-bash">curl -k -XGET https://raw.githubusercontent.com/Mrc0113/ep-design-workshop/main/EventPortalExport_Initial.json -o EventPortalExport_Initial.json
</code></pre>
<p>OR</p>
<pre><code language="language-bash" class="language-bash">git clone https://github.com/Mrc0113/ep-design-workshop.git
</code></pre>
<p>‚úÖ Inside your logged into Solace Cloud Account navigate to the Event Portal Designer by clicking &#34;Designer&#34; in the menu on the left.</p>
<p class="image-container"><img alt="ep_select_designer" src="img/554f234020ab9788.png"></p>
<p>‚úÖ Then import the previously downloaded Application Domain file by clicking the <code>Import</code> button at the top right of the <em>Designer</em> and importing the file.</p>
<p class="image-container"><img alt="ep_click_import" src="img/74dc40267b4899c1.png"></p>
<p>üöÄ Setup complete! Let&#39;s get going! üöÄ</p>


      </google-codelab-step>
    
      <google-codelab-step label="Use Case Overview" duration="5">
        <p>You are a member of the engineering team at the <em>NYC Modern Taxi Co</em>, a fictional taxi cab company based in New York City. Your team is playing from behind and racing to catch up with technology innovation introduced to the industry by Rideshare competitors such as Uber and Lyft. In order for the company to survive and eventually thrive your team has convinced the board that transforming the companies&#39; IT systems is of utmost importance. Your team has done its research and determined that moving to an Event-Driven Architecture is essential to future rapid innovation and has already kicked this initiative off by deploying a Solace Event Mesh and updating the taxi fleet to stream real-time events that include ride and location information. We know what the fleet is up to! Now it&#39;s time to start to continually improve and provide a world class customer experience.</p>
<p>In order to react in a real-time manner the team has decided that we want to process the updates as they stream in from the fleet of taxis instead of putting them directly into a datastore and then having to retrieve them to do processing later. To prototype this work, you&#39;ll see a high level design in the diagram below. Since we already have the taxi fleet streaming their updates into our PubSub+ Event Mesh we need to do the following:</p>
<ol type="1">
<li>üöñ Create and capture this <strong>design</strong> in the PubSub+ Event Portal where we can define our Event-Driven Architecture, including its components: Applications, Events, and Schemas. This will allow us to define the details needed to implement, visualize and extend the architecture as it evolves, and share/collaborate with our entire engineering team as we continue to innovate.</li>
<li>üöï Next up we&#39;re going to <strong>document</strong> few applications and events so that they can be understood and reused by others.</li>
<li>üöï Learn, Understand and Reuse some of our events in a new use case</li>
<li>üöñ Lastly we&#39;ll <strong>develop</strong> the <em>ProcessPayment</em> microservice that that receives the stream of <em>RideUpdated</em> events, charges the customer&#39;s credit card and generate a <em>PaymentCharged</em> Event.</li>
</ol>
<p class="image-container"><img alt="Architecture" src="img/d2787790c0b40fe1.jpg"></p>
<aside class="special"><p> The dataset you will be using in this lab originally comes from the NYC Taxi &amp; Limousine Commission&#39;s open data release of more than a billion taxi ride records. Google then extended one week worth of data (3M taxi rides) from their original pickup and drop-off points into full routes in order to simulate a fleet of taxis roaming the streets of NYC. Solace is streaming this data over Solace PubSub+ for you to analyze and process.</p>
</aside>
<p><em>Terms of Use:</em> This dataset is publicly available for anyone to use under the following terms provided by the Dataset Source ‚Äî <a href="https://data.cityofnewyork.us/" target="_blank">https://data.cityofnewyork.us/</a> ‚Äî and is provided &#34;AS IS&#34; without any warranty, express or implied, from Solace. Solace disclaims all liability for any damages, direct or indirect, resulting from the use of the dataset.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Foundational Concepts" duration="8">
        <p>Before we dive deeper, let&#39;s ensure we are all aligned with terminology of the objects and concepts we will use in PubSub+ Event Portal.</p>
<h2 is-upgraded>Application Domain &amp; Workspace</h2>
<p>An application domain represents a namespace where applications, events, and schemas can live. Within this namespace, you can create a suite of applications, events, and schemas that are independent of other application domains. In our NYC Taxi use case we introduced earlier, we may group applications into different domains, for ex. we may have a domain for our rideshare apps and services, one for our <em>back-office apps</em> where invoicing and background checks are being processed, and maybe another domains for <em>analytics</em> where we group apps that are responsible for analyzing the successful operation of our rideshare services.</p>
<p class="image-container"><img alt="Workspace Example" src="img/683565240d58a47f.png"></p>
<h2 is-upgraded>Events/Topics</h2>
<p>Events are an important part of the Event Portal. Think of an event as a concept of the publish-subscribe (pub/sub) architectural pattern. Topics are used to route data or events (in the form of messages) between distributed applications, often using a message broker or an event broker.</p>
<p>A Solace topic and an Apache Kafka topic might seem fundamentally the same, but there are quite a few <a href="https://solace.com/blog/solace-topics-vs-kafka-topics/" target="_blank">differences between them</a>.</p>
<p>Here are some examples from our use case:</p>
<p>Kafka Topics:</p>
<ul>
<li>taxinyc.analytics.fraud.alerted.v1</li>
<li>taxinyc.ops.payment.charged.v1</li>
<li>taxinyc.ops.ride.called.v1</li>
</ul>
<p>Solace Topics:</p>
<ul>
<li>taxinyc/ops/ride/updated/v1/{ride_status}/{driver_id}/{passenger_id}/{current_latitude}/{current_longitude}</li>
<li>taxinyc/backoffice/payment/charged/v1/{payment_status}/{driver_id}/{passenger_id}</li>
</ul>
<h2 is-upgraded>Schemas</h2>
<p>In simple terms, a schema represents the contract to describe the payload of an event. Producers and consumers of an event can trust that the event&#39;s payload matches the schema definition assigned to that event. Schemas define a type of payload through JSON, AVRO, XML, Binary, or Text. JSON, AVRO, and XML schemas have content that describes each property of the schema.</p>
<p>In our use case all events are in JSON Schema format.</p>
<p class="image-container"><img alt="Schema Example" src="img/db2a01b2d4b490dd.png"></p>
<h2 is-upgraded>Applications</h2>
<p>An application represents a piece of software that produces and consumes events. Applications connect to the event broker in an event-driven architecture and communicate with other applications via events. A single application represents a class of applications that are running the same code base; therefore, a Kafka consumer group can be associated with an Application object in the Event Portal.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Best Practices" duration="8">
        <h2 is-upgraded>Decomposing the Enterprise</h2>
<p>It is important to consider how your enterprise is organized so that it can be decomposed using the Application Domain construct. An Application Domain provides the ability to organize and decompose an enterprise into logical groupings. These groupings could be based on-line of business, related functional capabilities or based on team dynamics. The benefits of doing this includes:</p>
<ol type="1">
<li><strong>Event sharing rules</strong> ‚Äì decide which events should be shared with other application domains and those which are for internal application domain usage only. This has implications both from a security perspective, but also which events need to be managed more tightly as they affect others outside the application domain</li>
<li><strong>Provide uniform event topic prefixes</strong> ‚Äì ensures that the prefix is unique and that topic best practices are followed</li>
</ol>
<h2 is-upgraded>Topic Naming Best Practices</h2>
<p>aside The topic of which an event is addressed seems like a pretty simple decision, but in reality, it can result in some negative consequences if not planned &gt;n advance. A topic is more than an address, it is metadata that describes the event and can be used for several purposes such as routing, access control and versioning. Thus, it is important to properly govern and manage the topic structure. <strong>Regardless of your broker type</strong>, it is a good practice to make topics structured and hierarchical the same way a RESTful Resource uses hierarchical addressing. In other words we want to produce hierarchical topics that rank from least specific to most specific.</p>
<h3 is-upgraded>Parts of the Event Topic</h3>
<p>The event topic structure has two parts:</p>
<ol type="1">
<li>The <strong>Event Topic Root</strong> contains enough information to describe the type of event that has occurred. Each Event Topic Root is a static field that describes the type of event. The list of Event Topic Roots forms a catalog of events that can be produced and consumed. This catalog could be brought into the PubSub+ Event Portal&#39;s event catalog, listing each event type along with details about the event. Each Event Topic Root describes the event in as much detail as necessary to map it to a single data schema.</li>
<li>The <strong>Event Topic Properties</strong> are optional fields that further describe a particular event. This part of the topic has fields that are dynamically filled when the producer publishes the event. These fields are used to describe the specific or unique attributes of this event instance that would be used for routing and filtering.</li>
</ol>
<ul>
<li>Event Topic Root: The Event Topic Root of an event should have the following form:<pre><code>  Domain/ObjectType/Verb/Version/
</code></pre>
</li>
<li>Event Topic Properties: The Event Topic Properties should have the following form: Locality/SourceID/ObjectID</li>
</ul>
<aside class="special"><p> Complete Event Topic Format: Putting together an Event Topic Root and Event Topic Properties creates an event topic that describes the event with a series of fields from least specific to most specific.</p>
<pre><code>    Domain/ObjectType/Verb/Version/Locality/SourceID/ObjectID
</code></pre>
<p>For more information about topic best practices, review the <a href="https://docs.solace.com/Best-Practices/Topic-Architecture-Best-Practices.htm" target="_blank">Topic Architecture Best Practices Guide</a></p>
</aside>
<h2 is-upgraded>Event Information Exchange Patterns</h2>
<p>There are multiple Event Exchange Patterns (EEP) that should be considered when using EDA:</p>
<h3 is-upgraded>Thin Event Notification</h3>
<ul>
<li>If using a <em>Thin Event Notification</em> pattern, where only the necessary details are provided from a data point of view, this does tend to increase coupling between the event source and sink&#39;s (consumers) as what attributes are provided are typically directly correlated with the needs of the use case vs being more flexible.</li>
</ul>
<aside class="special"><p> The advantage of this pattern however is that the data is smaller and can thus reduce latency and bandwidth when important. In general, the source of that event should be the single authoritative source for all published attributes.</p>
</aside>
<h3 is-upgraded>Hypermedia-Driven Events</h3>
<ul>
<li>If using <em>Hypermedia-Driven Events</em> pattern, links are provided in the event payload and works to bridge event notifications with dynamic API backends. This can be a good pattern to use where multiple levels of security are concerned related to attributes of the event. Consumers are still notified in realtime of state changes but must invoke the hyperlink in order to get access to more data. The service can then filter the response based on the client&#39;s access level.</li>
</ul>
<aside class="warning"><p> The disadvantage to this pattern is it increases the latency of the interaction as all the data is not available within the event and puts more complexity on the client and its behavior.</p>
</aside>
<h3 is-upgraded>Event-Carried State Transfer</h3>
<ul>
<li>If using <em>Event-Carried State Transfer</em> pattern, all known data is broadcast with the event (possibly entire record) thus enabling the consuming system to know the entire entity state vs just what changed as is the case with Thin Events. This is very common approach as many times the subscribing application want the entire snapshot to avoid having to persist previous state changes.</li>
</ul>
<aside class="warning"><p> The challenge in this case is that the publishing application may not be the authoritative source of all attributes published. Additionally, the event may become large and increase latency/decrease performance.</p>
</aside>
<aside class="special"><p> The benefit however is that decoupling has been achieved in that it will support a variety of use cases and the publisher does not need to be aware of the client&#39;s usage of the data.</p>
</aside>
<p>For more information about discovering, organizing and enhancing your Event-Driven Architecture, review [Understand, Manage, and Enhance Your Event-Driven Architecture Lifecycle ] (https://docs.solace.com/Cloud/Event-Portal/get-started-event-portal-user-scenario.htm)</p>


      </google-codelab-step>
    
      <google-codelab-step label="Design an Event Driven Architecture" duration="10">
        <p>By designing a new event-driven application or extending your event-driven architecture, you&#39;re able to deliver new real-time business capabilities in a decoupled and reusable fashion. There are however several key elements which should be considered when designing events, schemas and applications including topic best practices, options for exchanging event data and sharing/visibility rules. Considering these things early will put you on the road to success and enable better reusability down the road.</p>
<p>Now that you&#39;re familiar with the use case üöï üöñ üöï and you&#39;ve imported the application domain into the Event Portal, let&#39;s update our Event-Driven Architecture (EDA).</p>
<p>Lets say that your tasked with working within the Back Office team (where the cool kids all work) and are asked to architect the way in which we will charge our passengers for their rides and if the passenger is part of a commercial account, send to our Invoicing System. This is composed of 4 steps</p>
<ol type="1">
<li>Ideate</li>
<li>Design the schema</li>
<li>Design the event</li>
<li>Design the applications</li>
</ol>
<h2 is-upgraded>Step 1: Determine What Can Trigger Payment - Ideate</h2>
<p>So essentially we need to consider, is there a business event that would help us trigger on the moment when the ride has been completed?</p>
<aside class="special"><p> Event-Driven Ideation: To create new business value you must be able to imagine or conceive of a new solution to an existing problem. These ideas can be derived from two different directions. First, I have a known problem, and I am searching for a solution or secondly, let us look at what is available and uncover unique solutions for problems we were not actively looking for. The Event Portal enables learnings from both directions as without it, you do not have a central location to capture all the events that are available, nor do you have a way to understand whether a given event stream solves your problem. The search and filter functionality enable the user to perform keyword searches which range from data level attributes to metadata within the description.</p>
</aside>
<ol type="1">
<li>Navigate to the <em>Catalog</em> component of the Event Portal<br><img src="img/8c42b9e724cdec6a.png"></li>
<li>Click on the <em>Schemas</em> tab and search for &#34;dropoff&#34; <img src="img/909c55ded23b1a9f.png"></li>
<li>In the Search Results click on the <strong>RideUpdated</strong> event in order to understand the matching text context.</li>
<li>We now know that the RideUpdated Schema has a field called <strong>ride_status</strong> that can have a value of <em>dropoff</em>. So how do we get access to that data? Click on the <em>RideUpdated</em> schema and we will find out! <img src="img/f4d8cb3f04b47e93.png"></li>
<li>We now see the metadata about the RideUpdated schema and at the bottom we can see there is an Event that references this schema called <em>RideUpdated</em>. The topic being used leverages the <strong>ride_status</strong> attribute which is pretty sweet! So we can filter on dropoff as a client. <img src="img/38e0d89b8245b7b.png"></li>
</ol>
<h2 is-upgraded>Step 2: Design the <em>PaymentCharged</em> Schema</h2>
<p>Next we should decide what we want the data to look like once we have processed a payment.</p>
<ol type="1">
<li>First we must decide what Event Exchange Pattern (EEP) we will use. For Maximum flexibility, and because time is not of the essence, we will leverage &#34;Event-Carried State Transfer&#34;.</li>
<li>Click into the <em>Designer</em> component of the Event Portal<br><img src="img/845781a9130c9a0d.png"></li>
<li>Double-click on the <em>NYC Modern Taxi Co - Back Office</em> Application Domain and its time to get creating! <img src="img/3c793ad40de9e968.gif"></li>
<li>Click on the Schema tab</li>
<li>On the Upper Right Corner, Click the <em>Create</em> button and select <em>Create Schema<br></em><img src="img/a53e8ba9b8d49f3a.png"></li>
<li>Create Schema by setting values:<ol type="1">
<li>Name: PaymentCharged</li>
<li>Content Type: JSON</li>
<li>Shared: YES</li>
<li>Owner: Assign Yourself</li>
<li>Tags: NONE</li>
<li>Description: NONE</li>
<li>Versions: Leave unchecked</li>
<li>Content:</li>
</ol>
</li>
</ol>
<pre><code language="language-yaml" class="language-yaml">{
  &#34;$schema&#34;: &#34;http://json-schema.org/draft-07/schema&#34;,
  &#34;$id&#34;: &#34;http://example.com/example.json&#34;,
  &#34;type&#34;: &#34;object&#34;,
  &#34;title&#34;: &#34;The root schema&#34;,
  &#34;description&#34;: &#34;The root schema comprises the entire JSON document.&#34;,
  &#34;default&#34;: {},
  &#34;examples&#34;: [
    {
      &#34;payment_charged_id&#34;: &#34;23232323&#34;,
      &#34;timestamp&#34;: &#34;2020-06-03T16:51:47.29612-04:00&#34;,
      &#34;information_source&#34;: &#34;ProcessPayment&#34;,
      &#34;payment_status&#34;: &#34;accepted&#34;,
      &#34;invoice_system_id&#34;: &#34;PSG-32923&#34;,
      &#34;amount_charged&#34;: 12.32,
      &#34;ride_id&#34;: &#34;545496c5-a334-4344-9662-efde68c0b98a&#34;,
      &#34;entity_type&#34;: &#34;Driver&#34;,
      &#34;driver&#34;: {
        &#34;driver_id&#34;: 1234132,
        &#34;first_name&#34;: &#34;Frank&#34;,
        &#34;last_name&#34;: &#34;Smith&#34;,
        &#34;rating&#34;: 4,
        &#34;car_class&#34;: &#34;SUV&#34;
      },
      &#34;passenger&#34;: {
        &#34;passenger_id&#34;: 2345243,
        &#34;first_name&#34;: &#34;Jesse&#34;,
        &#34;last_name&#34;: &#34;Menning&#34;,
        &#34;rating&#34;: 2
      }
    }
  ],
  &#34;required&#34;: [
    &#34;payment_charged_id&#34;,
    &#34;timestamp&#34;,
    &#34;information_source&#34;,
    &#34;payment_status&#34;,
    &#34;invoice_system_id&#34;,
    &#34;amount_charged&#34;,
    &#34;ride_id&#34;,
    &#34;entity_type&#34;,
    &#34;driver&#34;,
    &#34;passenger&#34;
  ],    
  &#34;properties&#34;: {
    &#34;payment_charged_id&#34;: {
      &#34;$id&#34;: &#34;#/properties/payment_charged_id&#34;,
      &#34;type&#34;: &#34;string&#34;,
      &#34;title&#34;: &#34;The payment_charged_id schema&#34;,
      &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
      &#34;default&#34;: &#34;&#34;,
      &#34;examples&#34;: [&#34;23232323&#34;]
    },
    &#34;timestamp&#34;: {
      &#34;$id&#34;: &#34;#/properties/timestamp&#34;,
      &#34;type&#34;: &#34;string&#34;,
      &#34;title&#34;: &#34;The timestamp schema&#34;,
      &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
      &#34;default&#34;: &#34;&#34;,
      &#34;examples&#34;: [&#34;2020-06-03T16:51:47.29612-04:00&#34;]
    },
    &#34;information_source&#34;: {
      &#34;$id&#34;: &#34;#/properties/information_source&#34;,
      &#34;type&#34;: &#34;string&#34;,
      &#34;title&#34;: &#34;The information_source schema&#34;,
      &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
      &#34;default&#34;: &#34;&#34;,
      &#34;examples&#34;: [&#34;ProcessPayment&#34;]
    },
    &#34;payment_status&#34;: {
      &#34;$id&#34;: &#34;#/properties/payment_status&#34;,
      &#34;type&#34;: &#34;string&#34;,
      &#34;title&#34;: &#34;The payment_status schema&#34;,
      &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
      &#34;default&#34;: &#34;&#34;,
      &#34;examples&#34;: [&#34;accepted&#34;]
    },
    &#34;invoice_system_id&#34;: {
      &#34;$id&#34;: &#34;#/properties/invoice_system_id&#34;,
      &#34;type&#34;: &#34;string&#34;,
      &#34;title&#34;: &#34;The invoice_system_id schema&#34;,
      &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
      &#34;default&#34;: &#34;&#34;,
      &#34;examples&#34;: [&#34;PSG-32923&#34;]
    },
    &#34;amount_charged&#34;: {
      &#34;$id&#34;: &#34;#/properties/amount_charged&#34;,
      &#34;type&#34;: &#34;number&#34;,
      &#34;title&#34;: &#34;The amount_charged schema&#34;,
      &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
      &#34;default&#34;: 0,
      &#34;examples&#34;: [12.32]
    },
    &#34;ride_id&#34;: {
      &#34;$id&#34;: &#34;#/properties/ride_id&#34;,
      &#34;type&#34;: &#34;string&#34;,
      &#34;title&#34;: &#34;The ride_id schema&#34;,
      &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
      &#34;default&#34;: &#34;&#34;,
      &#34;examples&#34;: [&#34;545496c5-a334-4344-9662-efde68c0b98a&#34;]
    },
    &#34;entity_type&#34;: {
      &#34;$id&#34;: &#34;#/properties/entity_type&#34;,
      &#34;type&#34;: &#34;string&#34;,
      &#34;title&#34;: &#34;The entity_type schema&#34;,
      &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
      &#34;default&#34;: &#34;&#34;,
      &#34;examples&#34;: [&#34;Driver&#34;]
    },
    &#34;driver&#34;: {
      &#34;$id&#34;: &#34;#/properties/driver&#34;,
      &#34;type&#34;: &#34;object&#34;,
      &#34;title&#34;: &#34;The driver schema&#34;,
      &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
      &#34;default&#34;: {},
      &#34;examples&#34;: [
        {
          &#34;driver_id&#34;: 1234132,
          &#34;first_name&#34;: &#34;Frank&#34;,
          &#34;last_name&#34;: &#34;Smith&#34;,
          &#34;rating&#34;: 4,
          &#34;car_class&#34;: &#34;SUV&#34;
        }
      ],
      &#34;required&#34;: [
        &#34;driver_id&#34;,
        &#34;first_name&#34;,
        &#34;last_name&#34;,
        &#34;rating&#34;,
        &#34;car_class&#34;
      ],
      &#34;properties&#34;: {
        &#34;driver_id&#34;: {
          &#34;$id&#34;: &#34;#/properties/driver/properties/driver_id&#34;,
          &#34;type&#34;: &#34;integer&#34;,
          &#34;title&#34;: &#34;The driver_id schema&#34;,
          &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
          &#34;default&#34;: 0,
          &#34;examples&#34;: [1234132]
        },
        &#34;first_name&#34;: {
          &#34;$id&#34;: &#34;#/properties/driver/properties/first_name&#34;,
          &#34;type&#34;: &#34;string&#34;,
          &#34;title&#34;: &#34;The first_name schema&#34;,
          &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
          &#34;default&#34;: &#34;&#34;,
          &#34;examples&#34;: [&#34;Frank&#34;]
        },
        &#34;last_name&#34;: {
          &#34;$id&#34;: &#34;#/properties/driver/properties/last_name&#34;,
          &#34;type&#34;: &#34;string&#34;,
          &#34;title&#34;: &#34;The last_name schema&#34;,
          &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
          &#34;default&#34;: &#34;&#34;,
          &#34;examples&#34;: [&#34;Smith&#34;]
        },
        &#34;rating&#34;: {
          &#34;$id&#34;: &#34;#/properties/driver/properties/rating&#34;,
          &#34;type&#34;: &#34;number&#34;,
          &#34;title&#34;: &#34;The rating schema&#34;,
          &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
          &#34;default&#34;: 0,
          &#34;examples&#34;: [4]
        },
        &#34;car_class&#34;: {
          &#34;$id&#34;: &#34;#/properties/driver/properties/car_class&#34;,
          &#34;type&#34;: &#34;string&#34;,
          &#34;title&#34;: &#34;The car_class schema&#34;,
          &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
          &#34;default&#34;: &#34;&#34;,
          &#34;examples&#34;: [&#34;SUV&#34;]
        }
      },
      &#34;additionalProperties&#34;: true
    },
    &#34;passenger&#34;: {
      &#34;$id&#34;: &#34;#/properties/passenger&#34;,
      &#34;type&#34;: &#34;object&#34;,
      &#34;title&#34;: &#34;The passenger schema&#34;,
      &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
      &#34;default&#34;: {},
      &#34;examples&#34;: [
        {
          &#34;passenger_id&#34;: 2345243,
          &#34;first_name&#34;: &#34;Jesse&#34;,
          &#34;last_name&#34;: &#34;Menning&#34;,
          &#34;rating&#34;: 2
        }
      ],
      &#34;required&#34;: [&#34;passenger_id&#34;, &#34;first_name&#34;, &#34;last_name&#34;, &#34;rating&#34;],
      &#34;properties&#34;: {
        &#34;passenger_id&#34;: {
          &#34;$id&#34;: &#34;#/properties/passenger/properties/passenger_id&#34;,
          &#34;type&#34;: &#34;integer&#34;,
          &#34;title&#34;: &#34;The passenger_id schema&#34;,
          &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
          &#34;default&#34;: 0,
          &#34;examples&#34;: [2345243]
        },
        &#34;first_name&#34;: {
          &#34;$id&#34;: &#34;#/properties/passenger/properties/first_name&#34;,
          &#34;type&#34;: &#34;string&#34;,
          &#34;title&#34;: &#34;The first_name schema&#34;,
          &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
          &#34;default&#34;: &#34;&#34;,
          &#34;examples&#34;: [&#34;Jesse&#34;]
        },
        &#34;last_name&#34;: {
          &#34;$id&#34;: &#34;#/properties/passenger/properties/last_name&#34;,
          &#34;type&#34;: &#34;string&#34;,
          &#34;title&#34;: &#34;The last_name schema&#34;,
          &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
          &#34;default&#34;: &#34;&#34;,
          &#34;examples&#34;: [&#34;Menning&#34;]
        },
        &#34;rating&#34;: {
          &#34;$id&#34;: &#34;#/properties/passenger/properties/rating&#34;,
          &#34;type&#34;: &#34;number&#34;,
          &#34;title&#34;: &#34;The rating schema&#34;,
          &#34;description&#34;: &#34;An explanation about the purpose of this instance.&#34;,
          &#34;default&#34;: 0,
          &#34;examples&#34;: [2]
        }
      },
      &#34;additionalProperties&#34;: true
    }
  },
  &#34;additionalProperties&#34;: true
}


</code></pre>
<ol type="1" start="7">
<li>Revision Comment:  &#34;Initial Creation of Schema&#34;</li>
<li>Click <em>Save</em><img src="img/776f8e11d2060be8.png"></li>
</ol>
<h2 is-upgraded>Step 3: Design <em>PaymentCharged</em> Event</h2>
<p>So now that we have constructed the payload format for the PaymentCharged event, it is time to design the event itself. What&#39;s involved? Well we need to apply our best practices as it comes to the Topic name!</p>
<ol type="1">
<li>Click into the <em>Designer</em> component of the Event Portal</li>
<li>Double-Click on the <em>NYC Modern Taxi Co - Back Office</em> Application Domain</li>
<li>Click on the Events tab</li>
<li>On the Upper Right Corner, Click the <em>Create</em> button and select <em>Create Event</em><img src="img/f65bc169e5349cb7.png"></li>
<li>Create Event by setting values:<ol type="1">
<li>Name: PaymentCharged</li>
<li>Shared: YES</li>
<li>Description: NONE</li>
<li>Logical Event Mesh: NYC Modern Taxi Logical Event Mesh (default selection)</li>
<li>Description: NONE</li>
<li>Topic Address: Click on &#34;Set Topic Address&#34; <ul>
<li>As you can see the domain already has some &#34;Event Topic Root&#34; <code>taxinyc/backoffice/</code></li>
<li>We need to apply the best practice of <em>Domain/ObjectType/Verb/Version/Locality/SourceID/ObjectID</em> to this event</li>
<li>We will use the topic name of: <code>taxinyc/backoffice/payment/charged/v1/{payment_status}/{driver_id}/{passenger_id}</code></li>
<li>We will create topic levels <code>{payment_status}, {driver_id} and {passenger_id}</code> as variables</li>
</ul>
</li>
<li>Value: Keep the Schema radio button selected</li>
<li>Choose the Schema &#34;PaymentCharged&#34; that we created in the previous step</li>
<li>Owner: Assign Yourself</li>
<li>Tags: NONE</li>
<li>Revision Comment:  &#34;Initial Creation of Event&#34;</li>
<li>Click <em>Save</em></li>
</ol>
<img src="img/5b2523d8d9cd92f6.png"></li>
</ol>
<h2 is-upgraded>Step 4a: Design <em>ProcessPayment</em> Application</h2>
<p>Now for the fun part! We need to design the event-driven interface of the <em>ProcessPayment</em> Application. This is pretty easy as it has one input which triggers a single output.</p>
<ol type="1">
<li>Click into the <em>Designer</em> component of the Event Portal</li>
<li>Double-click on the <em>NYC Modern Taxi Co - Back Office</em> Application Domain</li>
<li>Click on the Applications tab</li>
<li>In the Upper Right Corner, Click the <em>Create</em> button and select <em>Create Application</em><img src="img/8e1f9d2650f18cf3.png"></li>
<li>Create Application by setting values:<ol type="1">
<li>Name: ProcessPayment</li>
<li>Description: NONE</li>
<li>Application Type: Standard</li>
<li>Owners: Assign Yourself</li>
<li>Tags: NONE</li>
<li>Associate Events - Click the <em>Manage</em> link <ol type="1">
<li>Select the <em>Sub</em> button next to the <em>RideUpdated</em> event</li>
<li>Select the <em>Pub</em> button next to the <em>PaymentCharged</em> event</li>
</ol>
</li>
</ol>
<img src="img/c66d57cbc2492b2c.png"><ol type="1" start="7">
<li>Revision Comment:  &#34;Initial Creation of Application&#34;</li>
<li>Click <em>Save</em></li>
</ol>
<img src="img/730383f7d849732e.png"></li>
<li>You should now see the newly added application on the graph! <img src="img/9e24a90ad6589bef.png"></li>
</ol>
<aside class="special"><p> Pro Tip!: If you wanted to develop/implement this application you could right-click on the <em>ProcessPayment</em> Application in graph and export an AsyncAPI Document that could be used to generate code!</p>
</aside>
<h2 is-upgraded>Step 4b: Design <em>InvoiceSystem</em> Application</h2>
<p>Remember back to our use case... We have designed how we process payment but still have to deal with invoicing customers when the payment_status says to invoice. Therefore, our plan is to create an application that integrates with our invoicing system.</p>
<ol type="1">
<li>Click into the <em>Designer</em> component of the Event Portal</li>
<li>Double-Click on the <em>NYC Modern Taxi Co - Back Office</em> Application Domain</li>
<li>Click on the Applications tab</li>
<li>On the Upper Right Corner, Click the <em>Create</em> button and select <em>Create Application</em><ol type="1">
<li>Name: InvoiceSystem</li>
<li>Description: NONE</li>
<li>Application Type: Standard</li>
<li>Owners: Assign Yourself</li>
<li>Tags: NONE</li>
<li>Associated Events - Click the <em>Manage</em> link <ol type="1">
<li>Select the <em>Sub</em> button next to the <em>PaymentCharged</em> event</li>
</ol>
</li>
</ol>
<img src="img/b1e96e6caa6e39f6.png"><ol type="1" start="2">
<li>Revision Comment:  &#34;Initial Creation of Application&#34;</li>
<li>Click <em>Save</em></li>
</ol>
<img src="img/730383f7d849732e.png"></li>
<li>You should now see the newly added application on the graph!</li>
</ol>
<p class="image-container"><img src="img/acfdcbd6bafb445e.png"></p>
<h2 is-upgraded>Reuse <em>PaymentCharged</em> Event</h2>
<p>Getting reuse of your events is an important part of proving return on investment (ROI) and also enables other applications and teams to integrate with realtime data.</p>
<p>In this scenario we will act as though we are members of the &#34;Ops&#34; team (they are not as cool as us back office kids, but oh well). They have a use case that Payment charged events should go to the <em>Rider Mobile Application</em>. Lets make it happen!</p>
<ol type="1">
<li>Click into the <em>Designer</em> component of the Event Portal</li>
<li>Double-click on the <em>NYC Modern Taxi Co - Ops</em> Application Domain</li>
<li>Double-click on the <em>RIder Mobile Application</em></li>
<li>On the Upper Right Corner, Click the <em>Edit</em> button</li>
<li>Associated Events - Click the <em>Manage</em> link <ol type="1">
<li>Select the <em>Sub</em> button next to the <em>PaymentCharged</em> event</li>
</ol>
</li>
<li>Revision Comment:  &#34;Updated to Satisfy JIRA-01245&#34;</li>
<li>Click <em>Save</em></li>
</ol>
<p>You should now see the relationship on the graph where we are subscribed to the <em>PaymentCharged</em> event and the dependency on the Back Office App domain!</p>
<p class="image-container"><img src="img/8ae8132fde2afe62.png"></p>
<aside class="special"><p> Change Impact Analysis: Changes happen. The question is what is the effect and who is affected? In the synchronous world changes to an API of course may/will affect the clients, so changes are rolled out, clients notified, and changes implemented. The challenge in the EDA world is that consumers are decoupled from producers and vice/versa. In addition, the ripple effect can be large in that integrations though connectors and integration capabilities can move events between different groups which further casts a fog upon dependency management. The Event Portal enables you to navigate the relationships you just designed and understand impact.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Documentation Best Practices" duration="5">
        <p>üí° <strong>Know your Audience<br></strong> The events which you have are used to enable real-time collaboration between systems and solve a problem for a specific industry and organization. These events are integrated into applications by software developers/engineers, but they are not all the same and can be decomposed into:</p>
<ul>
<li><strong>Decision Makers</strong> - Some people in the organization are looking and evaluating the events and schemas available in order to decide if it makes sense to have the development team further explore the service. They are evaluating with a problem in mind and are looking to see if the events registered within the Event Portal can be used to solve that problem. In many cases they will not be the ones writing the code that solves the problem but are extremely important as they drive the decision as to if the effort to use it will be undertaken. Examples of these types of decision makers include but are not limited to: CTO, Product Managers, Data Analysts and Data Scientists/Engineers.</li>
<li><strong>Users</strong> - These are the people who will be directly consuming and developing using the events and schemas defined in the event portal. Typically, the decision to use an event/schemas has been made, and they need to understand the event, how it applies to their use case and how to integrate with it. They are critical to enable as they are always short on time and are the last link to getting an event to be reused. In addition, these users are the ones creating the documentation to enable others if they are the author of an event or schema, so they are critical to the maintainability of the event-driven ecosystem of documentation. Examples of users include but are not limited to integration engineers, front end developer, backend developer.</li>
</ul>
<p>üí° <strong>Capture Business Point of View and Moment</strong></p>
<ul>
<li>The hardest thing to capture is the &#34;what does this event represent&#34; and without it, it will be hard for a decision maker to understand if it provides value. Be sure to document the moment in which the event was generated, the attributes of which it is the authoritative source and the intended use of the event. Do not assume the user will read the corresponding payload schema or understand much about the publishing application so focus on documenting the event concisely and thoroughly</li>
</ul>
<p>üí° <strong>Technical Requirements</strong></p>
<ul>
<li>This is the section where you need to provide the developer the information needed to consume the event itself. What are some suggest client APIs that should be used to consume the event? Are there important headers being used? What authentication/authorization schemes are required? All of this type of information should be captured to ensure an easy development process.</li>
</ul>
<p>üí° <strong>Link to other References</strong></p>
<ul>
<li>The Event Portal is just one source of information within the organization. Addition info on the application may be stored in a GitHub repo, so provide a link. A schema may also have a corresponding GitHub or wiki page, so provide a link. An event may have been a part of a larger development task tracked in JIRA, so provide a link. The point is link to all the places the organization captures information and ideally link from those places into the event portal so that no matter where you start, you can understand what&#39;s available and the state.</li>
</ul>
<p>üí° <strong>Provide Examples</strong></p>
<ul>
<li>An example can be an often-underutilized format of communication. By seeing an example of an event, the user may better understand a concrete business moment rather than the description. In addition, those examples are also all part of our search mechanism so anything within it provides better search context.</li>
</ul>
<p>üí° <strong>Terms of Use</strong></p>
<ul>
<li>This is the legal agreement between the event producer and any/all consumers. Talk to the API teams about their Terms of Use contracts and decide if it should be updated for event-driven API relationships. Also think of others within the same organization and their expectations of use and document them here.</li>
</ul>
<p>üí° <strong>Tags</strong></p>
<ul>
<li>When in doubt, add a tag (within reason). As more and more events, apps and schemas are input into the system, search and tagging becomes more and more important for users to find the capabilities available. Browse the existing tags and see which may apply to your event, application or schema. Add tags if needed so that others can more easily filter and find your event, application or schema.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Document Events, Applications, and Schemas" duration="8">
        <aside class="special"><p> Organizational Enablement: Organizational changes happen all the time. How ready are you to take over another groups EDA implementation? How about enable new members on yours? What if your current architect were to resign, are you capturing everything you should be? Tribal knowledge happens and is dangerous. The above organizational changes showcase the multitude of scenarios that can occur that leave the business in limbo and result in reverse engineering something that was already engineered. If you get into the habit and develop the muscle memory around designing/documenting and continuously validating your EDA, tribal knowledge is eliminated as its now available centrally and kept up to date. While most organizations believe they have a software development and governance process that will prevent this from happening, it is typically comprised of multiple conflicting sources of truth, none of which actually representing the current truth. This leads the team to constantly as the question &#34;so how does this actually work&#34; and wasting time trying to investigate vs simply using a tool that captures the information and ensures it matches reality.</p>
</aside>
<h2 is-upgraded>Update Documentation of <em>PaymentCharged</em> Event</h2>
<p>Remember how we did not provide any description or tags for the Events and Applications we created before? Well, lets go in and follow our best practices fixing this. Lets enhance the documentation of the <em>PaymentCharged</em> Event</p>
<ol type="1">
<li>Click into the <em>Designer</em> component of the Event Portal</li>
<li>Double-click on the <em>NYC Modern Taxi Co - Back Office</em> Application Domain</li>
<li>Double-click on the <em>PaymentCharged</em> Event in the graph <ol type="1">
<li>Click on the <em>Edit</em> button </li>
<li>Copy and Paste the following into the <em>Description</em> field:</li>
</ol>
</li>
</ol>
<pre><code>Description of Business Moment

	Overview:

		The PaymentCharged Event exists in order to notify other systems that we have attempted to charge the passenger. There are also other states such as:
            accepted - customer credit card on file has been charged
            declined - customer credit card on file has been declined
            org - the customer is part of a B2B org and does not provide automated payment


Technical Requirements

Format: JSON
Security Level: PCI

Terms of Use

N/A


</code></pre>
<ol type="1">
<li>Lets make it nicer to read by using bullets, bold, italics etc.</li>
<li>Lets now also add Tags <ol type="1">
<li>Click <em>Add/Remove Tags</em><ol type="1">
<li>Type <em>PCI</em> in the box and Select (Create a new tag) below.</li>
<li>Optionally add other tags.</li>
<li>Click Done</li>
</ol>
</li>
</ol>
</li>
<li>The documentation should look something like: <img alt="asyncapi_doc2" src="img/f4470839ed490b17.png"></li>
<li>Click <em>Save</em></li>
</ol>
<h2 is-upgraded>Update Documentation of <em>ProcessPayment</em> Application</h2>
<p>Lets enhance the documentation of the <em>ProcessPayment</em> Application and put our Documentation Best Practices to work!</p>
<ol type="1">
<li>Click into the <em>Designer</em> component of the Event Portal</li>
<li>Double-click on the <em>NYC Modern Taxi Co - Back Office</em> Application Domain</li>
<li>Double-click on the <em>ProcessPayment</em> Application in the graph <ol type="1">
<li>Click on the <em>Edit</em> button </li>
<li>Copy and Paste the following into the <em>Description</em> field:</li>
</ol>
</li>
</ol>
<pre><code>Description of Business Capability

Overview:

    The ProcessPayment application solely exists in order to monitor for when Passenger Rides are completed such that final billing can be performed against the passengers credit card. Because this application will need to look up the passenger&#39;s billing information it is important that security be taken into account as it will need to be PCI compliant. 
    
    Upon successful payment, the application shall emit an event to signify that payment has happened.

Technical Requirements

  Java Version:  OpenJDK 11.0.4
  Spring Cloud Version:  Hoxton.SR8
  Number of Instances: 1
  Cloud: AWS us-east
  Security Level: PCI
  Event Broker Profile: Solace


Source Code Repository

  github repo



Terms of Use

  N/A


</code></pre>
<ol type="1">
<li>Lets make it nicer to read by using bullets, bold, italics etc</li>
<li>Lets add a hyperlink to the <em>github repo</em> that points to https://github.com</li>
<li>Lets now also add Tags <ol type="1">
<li>Click <em>Add/Remove Tags</em><ol type="1">
<li>Type <em>PCI</em> in the box and Select below.</li>
<li>Optionally add other tags.</li>
<li>Click Done</li>
</ol>
</li>
</ol>
</li>
<li>The documentation should look something like: <img alt="asyncapi_doc2" src="img/e2bd8b31332e1cf3.png"></li>
<li>Click <em>Save</em></li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="The AsyncAPI Initiative" duration="3">
        <p>The <a href="https://www.asyncapi.com/" target="_blank">AsyncAPI Initiative</a> is an open source initiative that provides both the AsyncAPI specification to define your asynchronous APIs, and open source tools to enable developers to build and maintain an event-driven architecture.</p>
<aside class="special"><p> Learn More in the <a href="https://www.asyncapi.com/docs/getting-started" target="_blank">AsyncAPI Docs</a></p>
</aside>
<p>The AsyncAPI Generator allows you to generate a wide variety of things from an AsyncAPI document depending on what template you choose. The latest list of templates can be found <a href="https://github.com/asyncapi/generator#list-of-official-generator-templates" target="_blank">here</a></p>
<p class="image-container"><img alt="asyncapiSpecExample" src="img/395809f45bd779ee.webp"></p>
<p class="image-container"><img alt="asyncapiGeneratorTemplates" src="img/c03b3358f92da62a.png"></p>
<h2 is-upgraded>Install the AsyncAPI Generator</h2>
<p>Now that we&#39;ve defined the architecture for our use case in the Event Portal we&#39;re ready to write some code! But we don&#39;t want to have to write everything from scratch, so we&#39;re going to use the <a href="https://github.com/asyncapi/generator" target="_blank">AsyncAPI Generator</a></p>
<p>In order to use the AsyncAPI Generator we first need to install the CLI.</p>
<p>If you have the prerequisites installed as defined earlier in the &#34;What You&#39;ll Need&#34; section you should be able to pop open your terminal and use the command below to install the CLI.</p>
<pre><code language="language-bash" class="language-bash">npm install -g @asyncapi/generator
</code></pre>
<aside class="warning"><p> Note that the AsyncAPI project is continuously updated so if you previously installed the generator you can also use the command above to update to the latest.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Implement ProcessPayment (Java/Spring)" duration="12">
        <h2 is-upgraded>Develop the ProcessPayment Microservice</h2>
<p>üöï üöñ üöï üöñ üöï üöñ üöï üöñ üöï üöñ üöï üöñ üöï üöñ üöï On to developing the <em>ProcessPayment</em> App. As defined during the design sections of this codelab, we determined that this will be a microservice written using Java &amp; Spring. We are going to use the <a href="https://spring.io/projects/spring-cloud-stream" target="_blank">Spring Cloud Stream</a> framework to develop this microservice since it was created for the exact purpose of developing event-driven microservices. We&#39;ll also keep the business logic to a minimum to focus on the process of creating an event-driven microservice with AsyncAPI + Spring Cloud Stream and getting it running!</p>
<h3 is-upgraded>Generate the Code Skeleton</h3>
<p>Open the <code>NYC Modern Taxi Co - Back Office</code> Application Domain in the Solace Event Portal, right-click on the <em>ProcessPayment</em> application, Choose <em>AsyncAPI</em>, Choose <strong><em>YAML</em></strong> and click <em>Download</em></p>
<p class="image-container"><img alt="processPaymentAsyncapi" src="img/5531c5325066b12a.png"></p>
<aside class="special"><p> The AsyncAPI Java Spring Cloud Stream Generator Template includes many <a href="https://github.com/asyncapi/java-spring-cloud-stream-template#configuration-options" target="_blank">Configuration Options</a> that allow you to change what the generated code will look like.</p>
</aside>
<h3 is-upgraded><em>Direct Download of updated AsyncAPI document</em></h3>
<p>If you want a pre-populated file with changes and additions, you can download using the following command.</p>
<pre><code language="language-bash" class="language-bash">curl -k -XGET https://raw.githubusercontent.com/Mrc0113/ep-design-workshop/main/ProcessPayment.yml -o ProcessPayment.yaml
</code></pre>
<p>After downloading, directly go to <em>Code Generation</em> step.</p>
<h3 is-upgraded><em>Manual updates to AsyncAPI document</em></h3>
<p>Alternatively, you can follow the instruction and make changes to the AsyncAPI document.</p>
<p>Let&#39;s add a few of the template&#39;s configuration options to the downloaded AsyncAPI document.</p>
<ul>
<li>Add <code>x-scs-function-name: processPayment</code> immediately after the <strong>subscribe</strong> operation and the <strong>publish</strong> operation under our two channels. By adding this you are telling the generator the name of the function you would like to handle events being exchanged and by adding the same function-name for both  <em>subscribe</em> and  <em>publish</em> operation you are saying you want them handled by the same function!</li>
<li>Add <code>x-scs-destination: test/taxinyc/PaymentProcessorQueue</code> immediately after the <strong>subscribe</strong> operation. By adding this and using the <em>Solace</em> binder you are specifying the durable queue name if you&#39;re using a Consumer Group, or part of the temporary queue name if you&#39;re not. This will also add a topic subscription matching the channel specified in the AsyncAPI document to the queue.</li>
</ul>
<p>‚úÖ After adding those configuration options your channels section of the AsyncAPI document should look like the image below.</p>
<pre><code language="language-yaml" class="language-yaml">channels:
  &#39;taxinyc/backoffice/payment/charged/v1/{payment_status}/{driver_id}/{passenger_id}&#39;:
    subscribe:
      x-scs-function-name: processPayment
      x-scs-destination: test/taxinyc/PaymentProcessorQueue
      message:
        $ref: &#39;#/components/messages/PaymentCharged&#39;
  ....
  ....
  &#39;taxinyc/ops/ride/updated/v1/{ride_status}/{driver_id}/{passenger_id}/{current_latitude}/{current_longitude}&#39;:
    publish:
      x-scs-function-name: processPayment
      message:
        $ref: &#39;#/components/messages/RideUpdated&#39;
</code></pre>
<aside class="warning"><p> To work-around an issue in the AsncAPI code generator, the <code>$id</code> fields need to be removed. You can use the following command in the terminal to accomplish this.<br><code>sed -i '/$id:/d' ProcessPayment.yaml</code></p>
</aside>
<h3 is-upgraded><em>Code Generation</em></h3>
<p>üöÄ Our AsyncAPI document is now ready to generate the actual code so go over to your terminal and enter the command in the code snippet below.</p>
<p>Note the different pieces of the command:</p>
<ul>
<li><code>ag</code> is the AsyncAPI Generator command</li>
<li><code>-o</code> is the output directory</li>
<li><code>-p</code> allows you to specify <a href="https://github.com/asyncapi/java-spring-cloud-stream-template#parameters" target="_blank">parameters</a> defined for the template you&#39;re using</li>
<li><code>binder</code> is the Spring Cloud Stream binder you wish to use, in this case Solace</li>
<li><code>artifactId</code> &amp; <code>groupId</code> configure Maven params of the same names</li>
<li><code>javaPackage</code> specifies the Java Package to place the generated classes into</li>
<li><code>host</code>, <code>username</code>, <code>password</code> and <code>msgVpn</code> allow you to set binder connection information (use the connection detailed noted from the previous step).</li>
<li>The yaml file is our AsyncAPI document</li>
<li>And lastly, the <code>@asyncapi/java-spring-cloud-stream-template</code> is the AsyncAPI generator template that we are using.</li>
</ul>
<pre><code language="language-bash" class="language-bash">ag -o ProcessPayment -p binder=solace -p dynamicType=header -p artifactId=ProcessPayment -p groupId=org.taxi.nyc -p javaPackage=org.taxi.nyc -p host=taxi.messaging.solace.cloud:55555 -p username=public-taxi-user -p password=iliketaxis -p msgVpn=nyc-modern-taxi ProcessPayment.yaml @asyncapi/java-spring-cloud-stream-template
</code></pre>
<p>‚úÖ After running the command you should see output that ends with where you can find your generated files.</p>
<pre><code>Done! ‚ú®
Check out your shiny new generated files at /private/tmp/codelab/ProcessPayment.
</code></pre>
<h3 is-upgraded>Import and Explore the Generated Project</h3>
<p>The generated project is a Maven project so head over to your IDE and import the project, so we can add our business logic. Once imported you should see something like the image below.<br><img alt="projectsetup2" src="img/59af14bf8d137ab2.png"></p>
<aside class="warning"><p> If you are wondering why the POJO name has a character 1 ‚Äì it is because there already exists a schema with the same name.</p>
</aside>
<p>A few notes on the project:</p>
<ul>
<li>The generated java classes are in the <code>org.taxi.nyc</code> package that we specified.</li>
<li>The <code>PaymentCharged</code> and <code>RideUpdated</code> POJOs were generated from the schemas defined in our AsyncAPI document and includes getters/setters/toString/etc.</li>
<li><code>Application.java</code> contains a <code>processPayment</code> method which is a <code>Function</code> that takes in a <code>RideUpdated</code> POJO and returns a <code>PaymentCharged</code> POJO.</li>
<li>The <code>application.yml</code> file contains the Spring configuration which tells our app how to connect to Solace using the SCSt binder as well as which message channels to bind our methods to.</li>
<li>The <code>pom.xml</code> file contains the dependencies needed for the microservice. These include the <code>solace-cloud-starter-stream-solace</code> dependency which allows you to use the Solace SCSt. Binder.</li>
</ul>
<aside class="warning"><p> You can use a Java IDE like Eclipse or Spring Tool Suite to work with the generated Spring Boot application. Alternatively, you can also use a simple text editor like Visual Source Code or other text editors to make changes to the files.</p>
</aside>
<h3 is-upgraded><em>Updates to </em><em>application.yml</em></h3>
<p>There are certain updates required to the <em>applicaion.yaml</em> file to reflect destination names and subscriptions. You can use the following block of code and replace the content of <em>application.yml</em> file in the Spring project or manually make changes by following steps in the <em>Changes to application.yml</em> section.</p>
<pre><code language="language-yaml" class="language-yaml">spring:
  cloud:
    function:
      definition: processPayment
    stream:
      bindings:
        processPayment-out-0:
          destination: &#39;test/taxinyc/YOUR_NAME/backoffice/payment/charged/v1/accepted&#39;
        processPayment-in-0:
          destination: test/taxinyc/PaymentProcessorQueue
      solace:
        bindings:
          processPayment-in-0:
            consumer:
              queueAdditionalSubscriptions: &#34;taxinyc/ops/ride/updated/v1/dropoff/&gt;&#34;
      binders:
        solace-binder:
          type: solace
          environment:
            solace:
              java:
                host: &#39;taxi.messaging.solace.cloud:55555&#39;
                msgVpn: nyc-modern-taxi
                clientUsername: public-taxi-user
                clientPassword: iliketaxis
logging:
  level:
    root: info
    org:
      springframework: info
</code></pre>
<p>After updating the file, directly go to <em>Implement the Business Logic</em> step.</p>
<h3 is-upgraded><em>Changes to </em><em>application.yml</em></h3>
<p>If you choose to make manual changes, please follow the instructions here.</p>
<p>Dynamic topics (topics with variables enclosed by {,} characters) is not supported by the AsyncAPI Code Generator in cloud stream bindings.</p>
<p>Let us make the following changes to the <em>application.yml</em> file.</p>
<ul>
<li>Update the <em>destination</em> field in <em>spring.cloud.stream.bindings.processPayment-out-0</em> to <code>test/taxinyc/YOUR_UNIQUE_NAME/backoffice/payment/charged/v1/accepted</code></li>
</ul>
<p><strong>Be sure to replace YOUR_UNIQUE_NAME with your name or some unique field; and remember it for later!.</strong> Because there are potentially multiple people using a shared broker participating in this codelab at the same time we need to make sure we publish to a unique topic.</p>
<ul>
<li>We need information on <strong>all</strong> taxi dropoff events to process payments. We need to add additional queue subsription at the binder level. Insert the following block immediately after the spring.cloud.stream.bindings.<pre><code language="language-yaml" class="language-yaml">    solace:
      bindings:
        processPayment-in-0:
          consumer:
            queueAdditionalSubscriptions: &#34;taxinyc/ops/ride/updated/v1/dropoff/&gt;&#34;
</code></pre>
</li>
</ul>
<p>Now we have the ProcessPayment application subscribing to a dynamic topic <code>taxinyc/ops/ride/updated/v1/dropoff/></code> and publishing to <code>test/taxinyc/YOUR_UNIQUE_NAME/backoffice/payment/charged/v1/accepted</code> topic.</p>
<aside class="special"><p> Note that the <code>></code> symbol, when placed by itself as the last level in a topic, is a multi-level wildcard in Solace which subscribes to all events published to topics that begin with the same prefix. Example: <code>animals/domestic/></code> matches <code>animals/domestic/cats</code> and <code>animals/domestic/dogs</code>. <a href="https://docs.solace.com/PubSub-Basics/Wildcard-Charaters-Topic-Subs.htm" target="_blank">More wildcard info, including a single level wildcard, can be found in docs</a></p>
</aside>
<h3 is-upgraded>Implement the Business Logic</h3>
<p>Obviously in the real world you&#39;d have more complex business logic but for the sake of showing simplicity we&#39;re just going to log the <em>RideUpdated</em> events as they&#39;re received and create a new PaymentCharged event for each.</p>
<p>Open the <em>Application.java</em> file and modify the <code>processPayment</code> method to build and publish <em>PaymentCharged</em> event. Copy the following code block and replace the <code>processPayment</code> bean. Upon receiving a <em>RideUpdated</em> message, thie bean function constructs a <em>PaymentCharged</em> message and publishes to the unique topic (distinguished by your unique name).</p>
<pre><code language="language-java" class="language-java">@Bean
public Function&lt;RideUpdated1, Message&lt;PaymentCharged&gt;&gt; processPayment() {
  return rideUpdated -&gt; {
    logger.info(&#34;Received Ride Updated Event:&#34; + rideUpdated);

    // Process Payment
    PaymentCharged pc = new PaymentCharged();
    pc.setRideId(rideUpdated.getRideId());
    pc.setAmountCharged(rideUpdated.getMeterReading());
    pc.setPaymentStatus(&#34;accepted&#34;);
    pc.setPaymentChargedId(UUID.randomUUID().toString());
    pc.setInvoiceSystemId(&#34;PSG-&#34; + RandomUtils.nextInt());
    pc.setInformationSource(&#34;ProcessPayment Microservice&#34;);
    pc.setTimestamp(Instant.now().toString());
    pc.setEntityType(&#34;Driver&#34;);
    
    org.taxi.nyc.RideUpdated1.Driver driver = rideUpdated.getDriver();
    pc.setDriver(new org.taxi.nyc.PaymentCharged.Driver(
            driver.getDriverId(), driver.getRating(), driver.getLastName(), 
            driver.getCarClass(), driver.getFirstName()));
    
    org.taxi.nyc.RideUpdated1.Passenger passenger = rideUpdated.getPassenger();
    pc.setPassenger(new org.taxi.nyc.PaymentCharged.Passenger(
              passenger.getPassengerId(), passenger.getRating(),
              passenger.getLastName(), passenger.getFirstName()
            ));

    logger.info(&#34;Created PaymentCharged Event:&#34; + pc);
    
    String topic = &#34;test/taxinyc/YOUR_UNIQUE_NAME/backoffice/payment/charged/v1/accepted&#34;;
    Message&lt;PaymentCharged&gt; message = MessageBuilder
        .withPayload(pc)
        .setHeader(BinderHeaders.TARGET_DESTINATION, topic)
        .build();

    return message;
    
  };
}
</code></pre>
<p><strong>Be sure to replace YOUR_UNIQUE_NAME with your name or some unique field in the following line of code:</strong></p>
<pre><code>    String topic = &#34;test/taxinyc/YOUR_UNIQUE_NAME/backoffice/payment/charged/v1/accepted&#34;;
</code></pre>
<aside class="warning"><p> After updating the code, ensure that all &#34;Instant cannot be resolved&#34; errors due to missing imports. Or simply insert the following import statements at the top of the file.</p>
<pre><code>import java.time.Instant;
import java.util.UUID;
import org.apache.commons.lang.math.RandomUtils;
</code></pre>
</aside>
<p>That&#39;s it! The app development is complete.</p>
<h2 is-upgraded>Run the app!</h2>
<p>Now that our app has been developed let&#39;s run it!</p>
<p>If your IDE has support for Spring Boot you can run it as a Spring Boot App.</p>
<p>Or run it from the terminal by navigating to the directory with the pom and running the following command in the terminal.</p>
<p><code>mvn clean spring-boot:run</code></p>
<aside class="warning"><p> If you get an error that says something like <code>Web server failed to start. Port XXXX was already in use.</code> then change the <code>server.port</code> value in <code>application.yml</code> to an open port.</p>
</aside>
<p>Once running you should see that for each RideUpdated event that is received a PaymentCharged Event is created which is being published back out onto the broker for downstream apps to consume. The output should look something like the below.</p>
<pre><code language="language-log" class="language-log">2022-03-31 09:50:58.267  INFO 26107 --- [pool-4-thread-1] org.taxi.nyc.Application                 : 
Received Ride Updated Event:RideUpdated1 [ rideId: 056b4e73-60d6-4e90-bd29-0261d5824b5c heading: 35 latitude: 40.7888 passengerCount: 1 pointIdx: 545 informationSource: RideDispatcher speed: 18 driver: Driver [ driverId: 325 rating: 2.89 lastName: Ferro carClass: Coupe firstName: Florence ] passenger: Passenger [ passengerId: 66574939 rating: 4.39 lastName: Cast firstName: Sally ] meterIncrement: 0.0317431 longitude: -73.974224 timestamp: 2022-03-31T00:20:58.184-04:00 meterReading: 17.3 rideStatus: dropoff ]
2022-03-31 09:50:58.270  INFO 26107 --- [pool-4-thread-1] org.taxi.nyc.Application                 : 
Created PaymentCharged Event:PaymentCharged [ rideId: 056b4e73-60d6-4e90-bd29-0261d5824b5c entityType: Driver amountCharged: 17.3 driver: Driver [ driverId: 325 rating: 2.89 lastName: Ferro carClass: Coupe firstName: Florence ] paymentChargedId: 02917306-79ff-457c-b2bc-73a547bcfdbe passenger: Passenger [ passengerId: 66574939 rating: 4.39 lastName: Cast firstName: Sally ] paymentStatus: accepted invoiceSystemId: PSG-1656881013 informationSource: ProcessPayment Microservice timestamp: 2022-03-31T04:20:58.269Z ]

</code></pre>
<p>ü§Øü§Ø <strong>The Microservice is now Running, connected to the Solace Event Broker and processing events!</strong> ü§Øü§Ø</p>


      </google-codelab-step>
    
      <google-codelab-step label="Implement InvoiceSystem (Node.js w/ MQTT)" duration="8">
        <h2 is-upgraded>Develop the InvoiceSystem Node.js App</h2>
<p>üöï üöñ üöï üöñ üöï üöñ üöï üöñ üöï üöñ üöï üöñ üöï üöñ üöï On to developing the <em>InvoiceSystem</em> application. We will be using the Node.js service that uses Hermes package to communicate with our event broker over MQTT. To do this we will leverage the <a href="https://github.com/asyncapi/nodejs-template" target="_blank">Node.js AsyncAPI Generator Template</a> to bootstrap our app creation. Note that <a href="https://mqtt.org/" target="_blank">MQTT</a> is an open standard messaging protocol very popular in Internet of Things (IoT) world and is designed to be extremely lightweight and</p>
<h3 is-upgraded>Download AsyncAPI Document</h3>
<p>Open the <code>NYC Modern Taxi Co - Back Office</code> Application Domain in the Solace Event Portal, right-click on the <em>InvoiceSystem</em>, Choose <em>AsyncAPI</em>, Choose <strong><em>YAML</em></strong> and click <em>Download</em></p>
<p class="image-container"><img alt="invoiceSystemAsyncapi" src="img/13e740ea64dd6620.webp"></p>
<h3 is-upgraded><em>Direct Download of updated AsyncAPI document</em></h3>
<p>If you want a pre-populated file with changes and additions, you can download using the following command.</p>
<pre><code language="language-bash" class="language-bash">curl -k -XGET https://raw.githubusercontent.com/Mrc0113/ep-design-workshop/main/InvoiceSystem/asyncapi.yaml -o InvoiceSystem.yaml
</code></pre>
<p>After downloading, directly go to <em>Code Generation</em> step.</p>
<h3 is-upgraded><em>Manual updates to AsyncAPI document</em></h3>
<p>Alternatively, you can follow the instruction and make changes to the AsyncAPI document.</p>
<ul>
<li>Update the <strong>channel configuration to a static topic name</strong> on which the process payment message is published by the ProcessPayment application we built in the previous section. Also, <strong>add operationId to the publish</strong> operation.</li>
</ul>
<pre><code language="language-yaml" class="language-yaml">    channels:
      &#39;test/taxinyc/YOUR_UNIQUE_NAME/backoffice/payment/charged/v1/accepted&#39;:
        publish:
          operationId: receivePaymentCharged
</code></pre>
<p><strong>Be sure to replace YOUR_UNIQUE_NAME with your name or some unique field in the following line of code:</strong></p>
<ul>
<li>Add the <strong><code>name</code></strong><strong> parameter next to the </strong><strong><code>PaymentCharged</code></strong><strong> message</strong>.</li>
</ul>
<pre><code language="language-yaml" class="language-yaml">  messages:
    PaymentCharged:
      name: PaymentCharged

</code></pre>
<ul>
<li>Add <strong>server configuration</strong> at the end of the yaml file</li>
</ul>
<pre><code language="language-yaml" class="language-yaml">servers:    
  production:     
    url: &#39;mqtt://taxi.messaging.solace.cloud:8883&#39;
    protocol: mqtt

</code></pre>
<p>üöÄ Our AsyncAPI document is now ready to generate the actual code so go over to your terminal and enter the command in the code snippet below.</p>
<h3 is-upgraded><em>Code Generation</em></h3>
<p>Note the different pieces of the command:</p>
<ul>
<li><code>ag</code> is the AsyncAPI Generator command</li>
<li><code>-o</code> is the output directory</li>
<li><code>-p</code> is the parameter to specify server configuration to be utilized</li>
<li>The yaml file is our AsyncAPI document</li>
<li>And lastly, the <code>@asyncapi/nodejs-template</code> is the AsyncAPI generator template that we are using.</li>
</ul>
<pre><code language="language-bash" class="language-bash">ag InvoiceSystem.yaml @asyncapi/nodejs-template -o InvoiceSystem -p server=production
</code></pre>
<p>‚úÖ After running the command you should see output that ends with where you can find your generated files.</p>
<pre><code>Done! ‚ú®
Check out your shiny new generated files at /private/tmp/codelab/InvoiceSystem.
</code></pre>
<h3 is-upgraded>Explore the Generated Project</h3>
<p>The AsyncAPI Generator generated a nodejs project in the directory specified by the <code>-o</code> parameter so head over to your favorite Editor/IDE and open it up. Once opened you should see something like the image below.</p>
<p class="image-container"><img alt="nodejsProjectSetup" src="img/5319194e31a778e2.png"></p>
<p><strong>A few notes on the project:</strong></p>
<ul>
<li>The <code>test-taxinyc-YOUR_UNIQUE_NAME-backoffice-payment-charged-v1-accepted.js</code> in the <code>src/api/handlers</code> directory contains callback function that will receive subscribed messages. This is the place where you can implement your business logic (message processing).</li>
<li>The <code>common.yml</code> file in the <code>config</code> directory contains broker and application details.</li>
</ul>
<h3 is-upgraded>Add the broker connection and protocol info</h3>
<p>In the <strong>common.yml</strong> in the <em>config</em> directory:</p>
<ul>
<li>Update the <strong>protocol to mqtts from mqtt in both </strong><strong><code>url</code></strong><strong> and </strong><strong><code>protocol</code></strong><strong> fields.</strong></li>
</ul>
<p>Before coding our nodejs app let&#39;s go ahead and put our credentials in place.</p>
<ul>
<li>Add <strong>username and password details.</strong></li>
</ul>
<pre><code language="language-yaml" class="language-yaml">  broker:
    mqtt:
      url: mqtts://taxi.messaging.solace.cloud:8883
      topics: [&#34;test/taxinyc/YOUR_UNIQUE_NAME/backoffice/payment/charged/v1/accepted&#34;]
      qos:
      protocol: mqtts
      retain:
      subscribe: true
      config:
        username: &#34;public-taxi-user&#34;
        password: &#34;iliketaxis&#34;
</code></pre>
<p>That&#39;s it! The app development is complete.</p>
<p>üöÄüöÄüöÄ Was that simple enough for you!? üöÄüöÄüöÄ</p>
<h2 is-upgraded>Run the app!</h2>
<p>Now that our app has been developed let&#39;s run it!</p>
<pre><code language="language-bash" class="language-bash"># Go to the generated server

$ cd InvoiceSystem

# Build generated application

$ npm i

# Start server - Once running you should see PaymentCharged Events are received from the Broker. 
# The output should look something like the below.

$ npm start
&gt; invoice-system@0.0.1 start /Users/xxxx/gitsolace/work/InvoiceSystem
&gt; node src/api/index.js

 SUB  Subscribed to test/taxinyc/YOUR_UNIQUE_NAME/backoffice/payment/charged/v1/accepted
InvoiceSystem 0.0.1 is ready!

üîó  MQTT adapter is connected!
‚Üê test/taxinyc/YOUR_UNIQUE_NAME/backoffice/payment/charged/v1/accepted was received:
{
  driver: {
    rating: 2.24,
    driver_id: 77,
    last_name: &#39;Van Zandt&#39;,
    car_class: &#39;Coupe&#39;,
    first_name: &#39;Pablo&#39;
  },
  passenger: {
    rating: 4.65,
    passenger_id: 93731728,
    last_name: &#39;Schlicht&#39;,
    first_name: &#39;Aaron&#39;
  },
  timestamp: &#39;2022-03-31T04:23:34.055Z&#39;,
  ride_id: &#39;effd0ef8-6358-4592-ac97-2be6173bfa4d&#39;,
  entity_type: &#39;Driver&#39;,
  amount_charged: 14.3,
  payment_charged_id: &#39;553ef9a9-dd18-4112-b79d-970156d529d2&#39;,
  payment_status: &#39;accepted&#39;,
  invoice_system_id: &#39;PSG-1557019248&#39;,
  information_source: &#39;ProcessPayment Microservice&#39;
}
</code></pre>
<p>ü§Øü§Ø <strong>The Node.js app is now Running, connected to the Solace Event Broker  receiving and logging events!</strong> ü§Øü§Ø</p>


      </google-codelab-step>
    
      <google-codelab-step label="Implement: Other Options!" duration="4">
        <p>You can create event driven applications in a wide variety of different options as shown here: ![APIs and Protocols] (img/Solace-PubSub-Platform-Diagram-1.png)</p>
<h2 is-upgraded>Generate Custom Code</h2>
<p>Since the AsyncAPI Specification provides a machine-readable way to define your Asynchronous applications it allows for the creation of custom code generators. The easiest way to likely do this is to leverage the tooling that the AsyncAPI Initiative has already put in place and create a new template for the <a href="https://github.com/asyncapi/generator" target="_blank">AsyncAPI Generator</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Takeaways" duration="4">
        <p>‚úÖ Event Driven Architecture does not have to be hard if you understand some key fundamentals and follow best practices.</p>
<p>‚úÖ The Solace PubSub+ Event Portal is an excellent tool to design, visualize and document your Event-Driven Architecture, discover what events exist, collaborate with your team and kick start development via exporting of AsyncAPI documents.</p>
<p>‚úÖ AsyncAPI Generator templates allow developers to consistently create event-driven applications by generating code skeletons that are pre-wired with the events and channels defined in the AsyncAPI documents.</p>
<p class="image-container"><img alt="Solly Image Caption" src="img/44f356558033e250.gif"></p>
<p>Thanks for participating in this codelab! Let us know what you thought in the <a href="https://solace.community/" target="_blank">Solace Community Forum</a>! If you found any issues along the way we&#39;d appreciate it if you&#39;d raise them by clicking the Report a mistake button at the bottom left of this codelab.</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
