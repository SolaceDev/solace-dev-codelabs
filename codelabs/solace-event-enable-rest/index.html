
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>How to Event-Enable your REST Architecture with Solace PubSub&#43;</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-3921398-10"></google-codelab-analytics>
  <google-codelab codelab-gaid="UA-3921398-10"
                  id="solace-event-enable-rest"
                  title="How to Event-Enable your REST Architecture with Solace PubSub&#43;"
                  environment="web"
                  feedback-link="https://github.com/SolaceDev/solace-dev-codelabs/blob/master/markdown/solace-event-enable-rest/solace-event-enable-rest.md">
    
      <google-codelab-step label="Introduction" duration="2">
        <h3 is-upgraded>&gt; Do you use <strong>REST-over-HTTP</strong> (<code>GET</code>, <code>POST</code>, etc.) for application communication??  Read on!</h3>
<p>In traditional microservice applications, the primary form of communication is often REST-over-HTTP.  However, this can be limiting as:</p>
<ul>
<li>REST archictecture is client-to-server (not bidirectional)</li>
<li>REST-over-HTTP is point-to-point (only one URL destination)</li>
<li>HTTP is a synchronous/blocking protocol (waiting for 200 OK)</li>
</ul>
<p>Modern applications are embracing <strong>publish-subscribe</strong> communication as a way to enable <strong>event-driven</strong> architectures.</p>
<ul>
<li>But how to migrate?</li>
<li>How to integrate?</li>
<li>Is it possible to combine both traditional REST interaction with efficient pub/sub communication??</li>
</ul>
<aside class="special"><p><strong>YES IT IS</strong>, using the <strong>Solace PubSub+ Event Broker!</strong></p>
</aside>
<h2 is-upgraded>What you&#39;ll build</h2>
<p class="image-container"><img alt="asdf" src="img/b2f8f4ad4e1dd723.png"></p>
<h2 class="checklist" is-upgraded>What you&#39;ll learn</h2>
<ul class="checklist">
<li>How to configure the Solace PubSub+ broker to accept incoming REST requests</li>
<li>How to configure the Solace broker to pass incoming REST requests straight though, similar to a proxy, using a Rest Delivery Point (RDP)</li>
<li>How to utilize the publish-subscribe pattern to allow easy access to multiple copies of the same data</li>
<li>How to build a Solace messaging application to consume and respond to incoming REST requests</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Prerequisites &amp; Assumptions" duration="2">
        <ul>
<li>It is assumed you have a basic understanding of what a Solace PubSub+ event broker is, and what it does.</li>
<li>You have access (and <em>admin</em> access) to a Solace PubSub+ broker. This can either be a hardware appliance, the software broker, or a Solace Cloud service instance.  (See below)</li>
<li>cURL, Postman, or other REST utility that will allow the injection of REST-over-HTTP requests.</li>
<li>(optional) A REST-enabled webserver, web application, or microservice that can accept incoming REST (GET, POST, etc.) requests, and generate a response. If not, the tuorial will use an available <a href="https://postman-echo.com" target="_blank">Postman test server</a>.</li>
<li>(optional) The Solace Java (JCSMP), JavaScript, C#, JMS, or other messaging API, which can be found at either <a href="https://solace.com/downloads" target="_blank">solace.com/downloads</a> or <a href="https://github.com/solacesamples" target="_blank">github.com/solacesamples</a>.</li>
</ul>
<aside class="warning"><p><strong>Note:</strong> this tutorial assumes that you are using the <code>default</code> Message VPN on the software broker. If not (e.g. hardware appliance, Solace Cloud, or just a different VPN), ensure you substitute the proper VPN name, username, etc. as you progress through this tutorial.</p>
</aside>
<h2 is-upgraded>Free Solace Access!</h2>
<ul>
<li><a href="https://console.solace.cloud/login/new-account" target="_blank">Sign up for a free Solace Cloud service (50 connections)</a></li>
<li><a href="https://solace.com/downloads/" target="_blank">Download the free feature-complete Standard Edition software broker</a></li>
<li><a href="https://youtu.be/s2n5V-IXCaM" target="_blank">Quickstart Video for Solace PubSub+ Docker container</a></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Overview of Sections: A, B, and C" duration="2">
        <p>This tutorial will walk though a number of steps to configure the Solace PubSub+ broker to be used in REST Gateway mode, as well as code examples using the Solace JCSMP (or other) API for building a request-reply backend messaging application.</p>
<h2 is-upgraded>Starting Configuration</h2>
<ul>
<li>In the beginning, you have a client making a REST reqeust to a backend REST server. (We&#39;ll use a free one if you don&#39;t have one available). <img alt="asdf" src="img/e453369ae33505ba.png"></li>
</ul>
<h2 is-upgraded>Part A</h2>
<ul>
<li>First, we configure and test the Solace PubSub+ broker to ensure it is receiving REST requests. Solace will convert the incoming requests to messages for testing. <img alt="asdf" src="img/b0922c0fe0eeb025.png"></li>
</ul>
<h2 is-upgraded>Part B</h2>
<ul>
<li>Next, configure all the necessary &#34;outbound&#34; REST components in the Solace broker to allow the REST request to reach the backend REST API, and respond.  This allows Solace to essentially be a REST proxy. <img alt="asdf" src="img/ef050d9e13dd1648.png"></li>
</ul>
<h2 is-upgraded>Part C</h2>
<ul>
<li>Finally, configure a &#34;sniffer&#34; messaging application to listen to the REST request/reply flow through Solace broker, using the publish-subscribe pattern. Could be very useful for logging, diagnostics, or audit. <img alt="asdf" src="img/ae516c9d616ce848.png"></li>
<li>Configure a messaging application to replace/extend/complement the backend REST server,  allowing a REST-to-pub/sub conversion within the Solace broker. <img alt="asdf" src="img/fb4e699993856e9a.png"></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Three Options for Config Management" duration="3">
        <p>You can (generally) configure the Solace PubSub+ broker using three different methods; this section provides a very brief outline of those.</p>
<p>Each section of this CodeLab that performs a configuration step on the Solace broker will include all three options.</p>
<aside class="warning"><p><strong>Note:</strong> do <em>not</em> perform all 3 configuration options, just choose 1 for each section.</p>
</aside>
<p>For any configuration management, you will need a username/password with either admin or read/write level privileges.</p>
<h2 is-upgraded>PubSub+ Manager GUI</h2>
<p>The PubSub+ Manager for Solace brokers is a web GUI, usually accessed on port 8080 on the software broker, port 80 of the management plane of the hardware appliance, or via the Solace Cloud console and clicking on &#34;Manage Service&#34; in the top right. (It is a replacement for SolAdmin, if you know that that is).</p>
<aside class="special"><p><strong>Tip:</strong> throughout the PubSub+ Manager, by clicking on any configuration item or attribute, a &#34;Tip&#34; will show on the right-hand side of the screen describing the object. Built-in help!</p>
</aside>
<p class="image-container"><img alt="alt-text-here" src="img/c1f978145c610f80.png"></p>
<h2 is-upgraded>SEMP Management API</h2>
<p>All of the commands and capabilities within the PubSub+ Manager can also be accomplished programmatically via the RESTful <strong>Solace Element Management Protocol</strong> (SEMP) API. For more information on the SEMP API, please consult the following links:</p>
<ul>
<li><a href="https://docs.solace.com/API-Developer-Online-Ref-Documentation/swagger-ui/config/index.html" target="_blank">SEMPv2 Swagger Reference Documentation</a></li>
<li><a href="https://docs.solace.com/SEMP/Using-SEMP.htm" target="_blank">SEMP User Guide</a></li>
</ul>
<h2 is-upgraded>Command Line Interface (CLI)</h2>
<p>The Solace <strong>Command Line Interface</strong> (CLI) can be reached by one of the following methods (as appropriate):</p>
<ul>
<li>Software broker, SSH to port 2222, and login with the admin username/password</li>
<li>Software broker running as Docker container: <code>sudo docker exec -it &lt;container-name&gt; cli</code></li>
<li>Software broker running as machine image: login to the machine image, then: <code>solacectl cli</code></li>
<li>Hardware appliance: login to port 22 of the management VRF</li>
</ul>
<p>Note that <code>show</code> commands can be run anywhere in CLI, from any &#34;level&#34;.  But configuration commands must be executed in a specific order.</p>
<p>I&#39;ve also included a lot of double-quotes <code>&#34;</code> in the CLI commands for completeness... but you almost never need to use them. FYI. (Just never put a space in any object name!!)</p>
<ul>
<li><a href="https://docs.solace.com/Solace-CLI/Using-Solace-CLI.htm" target="_blank">Solace CLI Reference Documentation</a></li>
<li><a href="https://solace.com/blog/getting-started-solos-cli/" target="_blank">Get Started with CLI (blog)</a></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Part A - Objective" duration="0">
        <h3 is-upgraded>Recall:</h3>
<ul>
<li>First we configure and test the Solace PubSub+ broker to ensure it is receiving REST requests. Solace will convert the incoming requests to messages for testing.</li>
</ul>
<p class="image-container"><img alt="asdf" src="img/b0922c0fe0eeb025.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="[A] Verify/Assign REST Port" duration="3">
        <p>In this first section, we will verify what port has been configured (if any) to allow incoming REST requests to your particular Message VPN. If using the <code>default</code> Message VPN on the software broker, this section can be skipped.</p>
<aside class="warning"><p><strong>Note:</strong> if creating a new Message VPN, you must configure a new/different port than one used by the <code>default</code> Message VPN, 9000. Each VPN needs different ports for REST connectivity.</p>
</aside>
<aside class="warning"><p><strong>Note:</strong> if using <strong>Docker</strong> for Windows, Docker for Mac, or using <code>bridge</code> networking mode with Docker on Linux, the new port must be added to the container&#39;s list of published ports (<code>-p &lt;new-port&gt;</code>) when the container is first instantiated (i.e. new ports are not automatically exposed).</p>
</aside>
<h2 is-upgraded>PubSub+ Manager</h2>
<p>Login to the PubSub+ GUI Manager, then select your Message VPN: <img alt="alt-text-here" src="img/af0b3dfe962b426c.png"></p>
<p>Select &#34;Services&#34; from the Message VPN&#39;s menu items: <img alt="alt-text-here" src="img/74e07d4141811e0.png"></p>
<p>Scroll down to the section on REST and verify the port is configured and enabled: <img alt="alt-text-here" src="img/fa6c165bf3a99a.png"></p>
<h2 is-upgraded>SEMP</h2>
<p>To view the incoming REST port, perform the following (replace <code>default</code> with your Message VPN name, and user credentials as appropriate):</p>
<pre><code>curl -u admin:admin http://localhost:8080/SEMP/v2/config/msgVpns/default?select=serviceRest*
</code></pre>
<p>And the response should look something like:</p>
<pre><code>{
    &#34;data&#34;:{
        &#34;serviceRestIncomingMaxConnectionCount&#34;:100,
        &#34;serviceRestIncomingPlainTextEnabled&#34;:true,        &lt;----
        &#34;serviceRestIncomingPlainTextListenPort&#34;:9000,     &lt;----
        &#34;serviceRestIncomingTlsEnabled&#34;:true,
        &#34;serviceRestIncomingTlsListenPort&#34;:9443
        &#34;serviceRestMode&#34;:&#34;messaging&#34;,
        &#34;serviceRestOutgoingMaxConnectionCount&#34;:100
    },
    &#34;links&#34;:{},
    &#34;meta&#34;:{
        &#34;request&#34;:{
            &#34;method&#34;:&#34;GET&#34;,
            &#34;uri&#34;:&#34;http://localhost:8080/SEMP/v2/config/msgVpns/default?select=serviceRestIncoming*&#34;
        },
        &#34;responseCode&#34;:200
    }
}
</code></pre>
<p>To configure the incoming port and enable it using SEMP, perform the following 2 commands. First, shutdown the port:</p>
<pre><code>curl http://localhost:8080/SEMP/v2/config/msgVpns/default \
  -X PATCH \
  -u admin:admin \
  -H &#34;Content-type:application/json&#34; \
  -d &#39;{ &#34;serviceRestIncomingPlainTextEnabled&#34;: false }&#39;
</code></pre>
<p>Then change the port number and re-enable it:</p>
<pre><code>curl http://localhost:8080/SEMP/v2/config/msgVpns/default \
  -X PATCH \
  -u admin:admin \
  -H &#34;Content-type:application/json&#34; \
  -d &#39;{ &#34;serviceRestIncomingPlainTextListenPort&#34;: 9001,
        &#34;serviceRestIncomingPlainTextEnabled&#34;: true }&#39;
</code></pre>
<h2 is-upgraded>CLI</h2>
<p>Perform the following <code>show</code> command in CLI.  Look for the line with <code>REST</code> and an <code>N</code> in the S(ecure) column for the port to use.  If the broker has a server certificate installed, you may use port in the line below (9443 in this case).</p>
<p>Note that <code>solace&gt;</code> is simply the prompt, ignore that.</p>
<pre><code>solace&gt; show message-vpn default service

// snip //
Service TP  S C VRF    Port A O Failed Reason
------- --- --- ----- ----- --- ------------------------------
SMF     TCP N N MsgBB 55555 U U
SMF     TCP N Y MsgBB 55003 U U
SMF     TCP Y N MsgBB 55443 U D No Cert
REST    WEB N - MsgBB  9000 U U              &lt;----
REST    WEB Y - MsgBB  9443 U D No Cert
SMF     WEB N - MsgBB    80 U U
SMF     WEB Y - MsgBB   443 U D No Cert
MQTT    TCP N - MsgBB  1883 U U
MQTT    TCP Y - MsgBB  8883 U D No Cert
// snip //
</code></pre>
<p>To configure a different port (e.g. if you are using a different Message VPN) and enable it, enter the following CLI commands in this exact order:</p>
<pre><code>home
enable
  config
    message-vpn &#34;default&#34;
      service rest
        incoming
          plain-text shutdown
          listen-port 9001
          no plain-text shutdown
          exit
</code></pre>
<h2 is-upgraded>Solace Cloud</h2>
<p>If using Solace Cloud, from within the console for your Solace Cloud instance, select &#34;Connect&#34;: <img alt="alt-text-here" src="img/fd52e4eebd267304.png"></p>
<p>Scroll down to the section on REST and verify the username, password, port, and URL: <img alt="alt-text-here" src="img/2727b40019421d6c.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="[A] Enable REST (Micro)Gateway Mode" duration="3">
        <p>In this section, we will switch the REST mode for our Message VPN from <em>Messaging</em> (the default) to <em>Gateway</em>. Microgateways allow Solace PubSub+ event brokers to act as HTTP load balancers, or simple API gateways between RESTful API clients and RESTful API service providers. Learn more about Microgateways <a href="https://docs.solace.com/Overviews/Microgateway-Concepts/Microgateways-Overview.htm" target="_blank">here</a></p>
<h2 is-upgraded>PubSub+ Manager</h2>
<p>Inside the &#34;Services&#34; menu of the Message VPN, either click &#34;Edit&#34; in the top-right, or double-click the Service Mode: <img alt="alt-text-here" src="img/41a9ff54db544a79.png"></p>
<p>Select <em>Gateway</em> from the drop-down list, and click &#34;Apply&#34;: <img alt="alt-text-here" src="img/846be83502b41b9f.png"></p>
<h2 is-upgraded>SEMP</h2>
<p>Change to <code>gateway</code> with just one command:</p>
<pre><code>curl http://localhost:8080/SEMP/v2/config/msgVpns/default \
  -X PATCH \
  -u admin:admin \
  -H &#34;Content-type:application/json&#34; \
  -d &#39;{ &#34;serviceRestMode&#34;: &#34;gateway&#34; }&#39;
</code></pre>
<p>To verify, use the previous GET command:</p>
<pre><code>curl -u admin:admin http://localhost:8080/SEMP/v2/config/msgVpns/default?select=serviceRest*
</code></pre>
<pre><code>{
    &#34;data&#34;:{
        &#34;serviceRestIncomingMaxConnectionCount&#34;:100,
        &#34;serviceRestIncomingPlainTextEnabled&#34;:true,
        &#34;serviceRestIncomingPlainTextListenPort&#34;:9000,
        &#34;serviceRestIncomingTlsEnabled&#34;:true,
        &#34;serviceRestIncomingTlsListenPort&#34;:9443,
        &#34;serviceRestMode&#34;:&#34;gateway&#34;,                       &lt;----
        &#34;serviceRestOutgoingMaxConnectionCount&#34;:100
    },
    &#34;links&#34;:{},
    &#34;meta&#34;:{
        &#34;request&#34;:{
            &#34;method&#34;:&#34;GET&#34;,
            &#34;uri&#34;:&#34;http://localhost:8080/SEMP/v2/config/msgVpns/default?select=serviceRest*&#34;
        },
        &#34;responseCode&#34;:200
    }
</code></pre>
<h2 is-upgraded>CLI</h2>
<p>Set the Message VPN into REST <code>gateway</code> mode with the following CLI commands. If continuing from the previous CLI command and are still at the <code>rest</code> level, simply enter the last line.</p>
<pre><code>home
enable
  config
    message-vpn &#34;default&#34;
      service rest
        mode gateway
</code></pre>
<pre><code>solace&gt; show message-vpn default

Message VPN:                         default
Configuration Status:                Enabled
Local Status:                        Up
Distributed Cache Management:        Enabled
SSL to plain text downgrade allowed: No
REST mode:                           Gateway     &lt;----
Total Local Unique Subscriptions:    9
// snip //
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="[A] Test REST Connectivity" duration="6">
        <p>Now that the Message VPN on the Solace broker has been configured for REST Gateway mode, let&#39;s verify that REST requests are reaching the broker.</p>
<h2 is-upgraded>Inject a REST Request</h2>
<p>Using cURL, Postman, or another REST program, inject a REST <code>GET</code> request to the broker on the correct port, using any path you&#39;d like.</p>
<aside class="warning"><p><strong>Note:</strong> the following is not a &#34;management&#34; command, and therefore the <strong>username</strong>, <strong>password</strong>, and <strong>port</strong> are different than the SEMP commands seen thus far. This would be a <em>client username</em> that you create for the Message VPN.</p>
</aside>
<p>For example:</p>
<pre><code>curl -u default:default http://localhost:9000/test -v
</code></pre>
<p>And you should see a response similar to the following:</p>
<pre><code>&lt;solace-error-response&gt;
&lt;code&gt;404&lt;/code&gt;
&lt;reason&gt;&lt;![CDATA[No Subscription Match]]&gt;&lt;/reason&gt;
&lt;detail&gt;&lt;![CDATA[
No subscription matching topic &#34;GET/test&#34;           &lt;----
]]&gt;&lt;/detail&gt;
&lt;internal-use&gt;1:7633&lt;/internal-use&gt;
&lt;/solace-error-response&gt;
</code></pre>
<p>Which means that it is reaching the broker, however there is nowhere to route this incoming request as there are no listeners currently configured.</p>
<aside class="special"><p><strong>Recall:</strong> in <code>gateway</code> mode, incoming REST requests are &#34;pre-pended&#34; with the REST VERB.  So a GET request for path <code>test</code> becomes a Solace message with topic <code>GET/test</code></p>
</aside>
<h2 is-upgraded>Consuming the Incoming REST Request</h2>
<p>As a test, to simply receive the incoming REST request, let&#39;s use the &#34;Try Me!&#34; test app built into the PubSub+ Manager:</p>
<p>Click on &#34;Try Me!&#34; on the left-hand menu: <img alt="alt-text-here" src="img/24e396b06edf57ce.png"></p>
<p>Click on &#34;Connect&#34; for the Subscriber on the right: <img alt="alt-text-here" src="img/23732d996a8c0c39.png"></p>
<p>Enter the subscription <code>GET/&gt;</code> into the text field, and click &#34;Subscribe&#34;.  Recall: the <code>&gt;</code> wildcard in Solace is a multi-level wildcard. This subscription will receive anything that is a &#34;GET&#34; request. <img alt="alt-text-here" src="img/f1a85ec757a124ec.png"></p>
<p>Resubmit the REST request from before, and it should pop up as a message on the Subscriber&#39;s received messages: <img alt="alt-text-here" src="img/608e4c1983261ac.png"></p>
<aside class="special"><p>Hooray!!</p>
</aside>
<h2 is-upgraded>How about POST requests?</h2>
<p>In the Subscriber application&#39;s subscription text field, try entering <code>POST/&gt;</code> as a subscription.  Then, submit a different REST request to see how it appears:</p>
<pre><code>curl -u default:default -X POST http://localhost:9000/hello/world -d &#39;{&#34;body&#34;:&#34;hello world!!&#34;,&#34;status&#34;:&#34;great&#34;}&#39; -v
</code></pre>
<p class="image-container"><img alt="alt-text-here" src="img/66866a3236c694e3.png"></p>
<aside class="special"><p>Awesome!!</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Part B - Objective" duration="0">
        <h3 is-upgraded>Recall:</h3>
<ul>
<li>Next, configure all the necessary &#34;outbound&#34; REST components in the Solace broker to allow the REST request to reach the backend REST API, and respond.  This allows Solace to essentially be a REST proxy.</li>
</ul>
<p class="image-container"><img alt="asdf" src="img/ef050d9e13dd1648.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="[B] Prepare for Outbound REST Pass-Through" duration="3">
        <p>For the Solace broker to act as a &#34;pass-through&#34; for REST requests in MicroGateway mode, we need to configure some additional &#34;outbound&#34; components on the broker.</p>
<ul>
<li><strong>A REST Delivery Point (RDP):</strong> this is the &#34;parent&#34; object which contains all the necessary configuration for sending outbound REST requests from the Solace broker</li>
<li><strong>A persistent Queue:</strong> each RDP is bound to one or more queues from which it receives messages</li>
<li><strong>A REST Consumer:</strong> this defines where/how the outbound request will be sent, essentially the destination</li>
</ul>
<p>The remainder of this tutorial will use a Postman API test server to generate a response to a HTTP GET request. If you have another API endpoint available to you that you&#39;d like to use, please feel free.</p>
<h2 is-upgraded>Test Server Details</h2>
<ul>
<li><strong>Host:</strong> postman-echo.com</li>
<li><strong>Port:</strong> 80</li>
<li><strong>Authentication:</strong> none</li>
</ul>
<p><a href="https://docs.postman-echo.com/?version=latest" target="_blank">Postman Echo Documentation</a></p>
<p>We will use the GET API to receive a response. The response will consist of some JSON, including any parameters that are passed with the URL.  E.g.:</p>
<pre><code>curl &#39;http://postman-echo.com:80/get?hello=world&amp;solace=cool&#39;
</code></pre>
<p>Should result in the following response (pretty-printed for visibility):</p>
<pre><code>{
  &#34;args&#34;: {
    &#34;hello&#34;: &#34;world&#34;
    &#34;solace&#34;: &#34;cool&#34;,
  },
  &#34;headers&#34;: {
    &#34;x-forwarded-proto&#34;: &#34;https&#34;,
    &#34;host&#34;: &#34;postman-echo.com&#34;,
    &#34;accept&#34;: &#34;*/*&#34;,
    &#34;user-agent&#34;: &#34;curl/7.58.0&#34;,
    &#34;x-forwarded-port&#34;: &#34;80&#34;
  },
  &#34;url&#34;:&#34;https://postman-echo.com/get?hello=world&amp;solace=cool&#34;
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="[B] Create a New Queue" duration="4">
        <p>When sending an outbound REST request, we need to configure a <strong>Queue</strong> to (temporarily) store the message before it gets sent out from the RDP.</p>
<aside class="warning"><p><strong>Note:</strong> if creating a <em>new</em> Message VPN, remember that the VPN&#39;s <code>max-spool-quota</code> size defaults to <strong>0MB</strong>. So when creating a new Message VPN, you must also increase the spool quota for your new VPN.</p>
</aside>
<h2 is-upgraded>PubSub+ Manager</h2>
<p>Click on &#34;Queues&#34; on the left-hand menu: <img alt="alt-text-here" src="img/5c41560d2a791a94.png"></p>
<p>Click on &#34;+ Queue&#34; in the top-right to create a new queue: <img alt="alt-text-here" src="img/103a322d6a191dc5.png"></p>
<p>Enter a name for your new queue. E.g. <code>q_rest_get</code>.  Click &#34;Create&#34;: <img alt="alt-text-here" src="img/5af6cb4f31f3b779.png"></p>
<p>Adjust any of the default attributes if you wish (e.g. message quota / queue size), although probably unnecessary.  Click &#34;Apply&#34;: <img alt="alt-text-here" src="img/9696840d1ec66ff9.png"></p>
<p>Click on the newly created queue to view it: <img alt="alt-text-here" src="img/1f999dda8905da3a.png"></p>
<p>Click on &#34;Subscriptions&#34;: <img alt="alt-text-here" src="img/c8ec4418974a5f66.png"></p>
<p>Click on &#34;+ Subscription&#34; in the top-right to add a new subscription(s): <img alt="alt-text-here" src="img/29c0606cb0cb347c.png"></p>
<p>Add the subscription <code>GET/&gt;</code> for the queue to attract <em>any</em> HTTP GET requests to the queue. Click &#34;Create&#34;: <img alt="alt-text-here" src="img/7fdee8d2ac20f98.png"></p>
<aside class="warning"><p><strong>Note:</strong> if you&#39;d like to use another HTTP verb – e.g. HTTP POST – then enter a different/another subscription here: e.g. <code>POST/&gt;</code> or restrict it to just the path you want: <code>GET/query</code>)</p>
</aside>
<p>You can read more about Wilecard Topic Subscriptions <a href="https://docs.solace.com/PubSub-Basics/Wildcard-Charaters-Topic-Subs.htm" target="_blank">here</a></p>
<h2 is-upgraded>SEMP</h2>
<p>Create a new queue:</p>
<pre><code>curl http://localhost:8080/SEMP/v2/config/msgVpns/default/queues \
  -X POST \
  -u admin:admin \
  -H &#34;Content-type:application/json&#34; \
  -d &#39;{ &#34;queueName&#34;: &#34;q_rest_get&#34;,
        &#34;accessType&#34;: &#34;exclusive&#34;,
        &#34;maxMsgSpoolUsage&#34;: 100,
        &#34;permission&#34;: &#34;consume&#34;,
        &#34;ingressEnabled&#34;: true,
        &#34;egressEnabled&#34;: true }&#39;
</code></pre>
<p>Add a subscription to it:</p>
<pre><code>curl http://localhost:8080/SEMP/v2/config/msgVpns/default/queues/q_rest_get/subscriptions \
  -X POST \
  -u admin:admin \
  -H &#34;Content-type:application/json&#34; \
  -d &#39;{ &#34;subscriptionTopic&#34;: &#34;GET/&gt;&#34; }&#39;
</code></pre>
<h2 is-upgraded>CLI</h2>
<pre><code>home
enable
  config
    message-spool message-vpn &#34;default&#34;
      create queue &#34;q_rest_get&#34;
      access-type exclusive
      permission all consume
      max-spool-usage 100
      subscription topic &#34;GET/&gt;&#34;
      no shutdown
      exit
    end

show queue q_rest_get detail
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="[B] Create a REST Delivery Point (RDP)" duration="5">
        <p>Next, we need to create a new <strong>Rest Delivery Point</strong> (RDP) and bind it to the new queue.</p>
<h2 is-upgraded>PubSub+ Manager</h2>
<p>Click on &#34;Client Connections&#34; on the left-hand menu: <img alt="alt-text-here" src="img/b26579c0aae663ff.png"></p>
<p>Click on &#34;REST&#34; in the top menu: <img alt="alt-text-here" src="img/cb75d916112063c9.png"></p>
<p>Click on &#34;+ REST Delivery Point&#34; in the top-right to create a new RDP: <img alt="alt-text-here" src="img/4aead515d78e9208.png"></p>
<p>Enter a name for your new RDP. E.g. <code>rdp_get</code>.  Click &#34;Create&#34;: <img alt="alt-text-here" src="img/a8aeaf423346ecc2.png"></p>
<p><strong>Enable</strong> the RDP. Click &#34;Apply&#34;: <img alt="alt-text-here" src="img/53039650bc44c671.png"></p>
<p>Click on the new RDP to view it: <img alt="alt-text-here" src="img/2888952921e81c89.png"></p>
<p>Click on &#34;Queue Bindings&#34; in the top menu: <img alt="alt-text-here" src="img/3c5e538ec934da79.png"></p>
<p>Click on &#34;+ Queue Binding&#34; in the top-right to create a new binding: <img alt="alt-text-here" src="img/9e409c350b684cc7.png"></p>
<p>Enter the name of your new queue to bind to this RDP, E.g. <code>q_rdp_get</code>. Click &#34;Create&#34;: <img alt="alt-text-here" src="img/fb1f2c8bcb80d285.png"></p>
<p>Click &#34;Apply&#34;: <img alt="alt-text-here" src="img/ca9d53339f4a3094.png"></p>
<h2 is-upgraded>SEMP</h2>
<pre><code>curl http://localhost:8080/SEMP/v2/config/msgVpns/default/restDeliveryPoints \
  -X POST \
  -u admin:admin \
  -H &#34;Content-type:application/json&#34; \
  -d &#39;{ &#34;restDeliveryPointName&#34;: &#34;rdp_get&#34;,
        &#34;enabled&#34;: true}&#39;

</code></pre>
<pre><code>curl http://localhost:8080/SEMP/v2/config/msgVpns/default/restDeliveryPoints/rdp_get/queueBindings \
  -X POST \
  -u admin:admin \
  -H &#34;Content-type:application/json&#34; \
  -d &#39;{ &#34;queueBindingName&#34;: &#34;q_rest_get&#34; }&#39;
</code></pre>
<h2 is-upgraded>CLI</h2>
<pre><code>home
enable
  config
    message-vpn &#34;default&#34;
      rest
        create rest-delivery-point &#34;rdp_get&#34;
          create queue-binding &#34;q_rest_get&#34;
          exit
        no shut

show message-vpn default rest rest-delivery-point * detail
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="[B] Configure a REST Consumer" duration="5">
        <p>The final configuration step on the Solace broker to allow the REST request to pass-through is the <strong>REST Consumer</strong>.  This is where the destination server/host is specified.</p>
<aside class="warning"><p><strong>Note:</strong> if you want to point the REST Consumer to a different REST API endpoint than the example <code>postman-echo.com</code>, you will amend some configuration settings in this section (e.g. authentication: basic, username/password).</p>
</aside>
<h2 is-upgraded>PubSub+ Manager</h2>
<p>From within the newly created RDP, click on &#34;REST Consumers&#34; in the top menu: <img alt="alt-text-here" src="img/5c78fe3036b77ba8.png"></p>
<p>Click on &#34;+ REST Consumer&#34; in the top-right to create a new consumer: <img alt="alt-text-here" src="img/48623b8b11c0f79d.png"></p>
<p>Enter a name for your new consumer. E.g. <code>rc_get</code>.  Click &#34;Create&#34;: <img alt="alt-text-here" src="img/4f455bd437b88661.png"></p>
<p>Enable the REST Consumer, and add the remote <strong>host</strong>, <strong>port</strong>, and any authentication required by the downstream REST server. In this example, the host is <code>postman-echo.com</code> and the port is <code>80</code>. Toggle the enable option and click &#34;Apply&#34; <img alt="alt-text-here" src="img/cf6a391678c076a2.png"></p>
<p>Refresh the screen, and ensure the REST Consumer reports an Operational State of <strong>Up</strong>: <img alt="alt-text-here" src="img/5766c3d98cb2d138.png"></p>
<h2 is-upgraded>SEMP</h2>
<p>One single SEMP API command will create and configure the REST Consumer:</p>
<pre><code>curl http://localhost:8080/SEMP/v2/config/msgVpns/default/restDeliveryPoints/rdp_get/restConsumers \
  -X POST \
  -u admin:admin \
  -H &#34;Content-type:application/json&#34; \
  -d &#39;{ &#34;restConsumerName&#34;: &#34;rc_get&#34;,
        &#34;authenticationScheme&#34;: &#34;none&#34;,
        &#34;remoteHost&#34;: &#34;postman-echo.com&#34;,
        &#34;remotePort&#34;: 80,
        &#34;tlsEnabled&#34;: false,
        &#34;enabled&#34;: true }&#39;


</code></pre>
<p>Make sure that it is reporting a good state, using the Monitor SEMP API:</p>
<pre><code>curl -u admin:admin http://localhost:8080/SEMP/v2/monitor/msgVpns/default/restDeliveryPoints/rdp_get/restConsumers
</code></pre>
<pre><code>{
    &#34;data&#34;:[
        {
            &#34;authenticationHttpBasicUsername&#34;:&#34;&#34;,
// snip //
            &#34;restConsumerName&#34;:&#34;rc_get&#34;,
            &#34;restDeliveryPointName&#34;:&#34;rdp_get&#34;,
            &#34;retryDelay&#34;:3,
            &#34;tlsCipherSuiteList&#34;:&#34;default&#34;,
            &#34;tlsEnabled&#34;:false,
            &#34;up&#34;:true                 &lt;----
        }
    ],
// snip //
</code></pre>
<h2 is-upgraded>CLI</h2>
<p>If continuing from the preious CLI command, and are still inside the <code>rest-delivery-point</code> level, start at line 7.</p>
<pre><code>home
enable
  config
    message-vpn &#34;default&#34;
      rest
        rest-delivery-point &#34;rdp_get&#34;
          create rest-consumer &#34;rc_get&#34;
            authentication auth-scheme none
            remote host &#34;postman-echo.com&#34;
            remote port 80
            no shut
</code></pre>
<p>You should now see something that looks like:</p>
<pre><code>solace&gt; show message-vpn default rest rest-consumer * detail

REST Consumer Name:                  rc_get
REST Delivery Point:                 rdp_get
Message VPN:                         default
Admin State:                         Enabled       &lt;----
Operational State:                   Up            &lt;----

Last Failure:
  Reason:                            Shutdown
  Time:                              Jan 30 2020 09:27:20 UTC
Last Conn Failure:
  Local Endpoint:                    N/A
  Remote Endpoint:                   N/A
  Reason:                            Unknown Connect Event
  Time:                              Jan 30 2020 09:24:49 UTC
Local:
  Interface:
Remote:
  Host:                              postman-echo.com
  Port:                              80
  SSL:                               No
  Outgoing Connections (up):         3       &lt;----
  Outgoing Connections (configured): 3       &lt;----
</code></pre>
<aside class="special"><p>Yay!</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="[B] Test one more time!" duration="3">
        <p>Now that the configuration is done, let us test using <em>almost</em> the same cURL command from before, except replacing the <code>postman-echo.com</code> host and port with the Solace broker&#39;s REST port, and adding client username &amp; password as required:</p>
<pre><code>curl -u default:default &#39;http://localhost:9000/get?hello=world&amp;solace=cool&#39;
</code></pre>
<p>And the output should look like:</p>
<pre><code>{
  &#34;args&#34;: {
    &#34;hello&#34;: &#34;world&#34;,
    &#34;solace&#34;: &#34;cool&#34;
  },
  &#34;headers&#34;: {
    &#34;x-forwarded-proto&#34;: &#34;https&#34;,
    &#34;host&#34;: &#34;postman-echo.com&#34;,
    &#34;accept&#34;: &#34;*/*&#34;,
    &#34;solace-delivery-mode&#34;: &#34;Non-Persistent&#34;,
    &#34;solace-message-id&#34;: &#34;ID:Solace-b7603db440727f09&#34;,
    &#34;solace-reply-wait-time-in-ms&#34;: &#34;FOREVER&#34;,
    &#34;solace-time-to-live-in-ms&#34;: &#34;30000&#34;,
    &#34;user-agent&#34;: &#34;curl/7.58.0&#34;,
    &#34;x-forwarded-port&#34;: &#34;80&#34;
  },
  &#34;url&#34;: &#34;https://postman-echo.com/get?hello=world&amp;solace=cool&#34;
}
</code></pre>
<p>Note the additional headers.  But the original requesting client (cURL in this case) is unaffected.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Part C - Objective" duration="0">
        <h3 is-upgraded>Recall:</h3>
<ul>
<li>Finally, configure a &#34;sniffer&#34; messaging application to listen to the REST request/reply flow through Solace broker, using the publish-subscribe pattern. Could be very useful for logging, diagnostics, or audit.</li>
</ul>
<p class="image-container"><img alt="asdf" src="img/ae516c9d616ce848.png"></p>
<ul>
<li>Configure a messaging application to replace/extend/complement the backend REST server,  allowing a REST-to-pub/sub conversion within the Solace broker.</li>
</ul>
<p class="image-container"><img alt="asdf" src="img/fb4e699993856e9a.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="[C] Configuring a &#34;Sniffer&#34; App" duration="4">
        <p>Just like we did on the last step of Section A, use the <strong>Try Me!</strong> functionality of the PubSub+ Manager to &#34;snoop&#34; or &#34;sniff&#34; the messages going through Solace:</p>
<p>Enter the subscriptions <code>GET/&gt;</code> and <code>#P2P/*/#rest*/&gt;</code> into the subscription text field. The 2nd subscription will receive all point-to-point replies for REST requests. <img alt="alt-text-here" src="img/86b0d684808f1c82.png"></p>
<p>Re-run the same cURL command from the previous section:</p>
<pre><code>curl -u default:default &#39;http://localhost:9000/get?hello=world&amp;solace=cool&#39;
</code></pre>
<p>Verify cURL still receives a response, but note that you can <strong>also</strong> see the request and reply in the Subscriber window: <img alt="alt-text-here" src="img/6167f19bb4a01a00.png"></p>
<aside class="special"><p>Similarly, you could configure a Java, C, JavaScript, C#, etc. client application using Solace APIs to receive the exact same messages by subscribing to the exact same topics.</p>
</aside>
<p>This shows that you can have an application passively receive <strong>a copy of all REST request-reply traffic</strong> as it moves through the broker, <strong>without impacting the original actors</strong>. This functionality could be very useful for logging, diagnostics, or audit.</p>


      </google-codelab-step>
    
      <google-codelab-step label="[C] Building a Replier Messaging App" duration="15">
        <h2 is-upgraded>(AKA Who Needs a REST Server??)</h2>
<p>Now that we have verified that the REST MicroGateway feature is passing through the various REST requests, let&#39;s take a look at some sample/example code to generate a response using a messaging topic consumer.</p>
<p>The following section assumes you are using the Solace Java JCSMP API, which is availalbe at our <a href="https://github.com/SolaceSamples/solace-samples-java" target="_blank">Samples GitHub repo</a>. However, the modifications and concepts apply to other Solace APIs and other messaging APIs (JMS, C, C#, JavaScript, etc.).  Other APIs are available on https://github.com/solacesamples/</p>
<aside class="special"><p>For a video guide on how to download, setup, run, and configure the Solace Java Samples, check out these videos: <a href="https://www.youtube.com/watch?v=eTcmeLzkFN8&list=PLY1Ks8JEfJR5H6LMgs6EJ_SYcDf3IZsjd&index=5" target="_blank">Solace Java Samples Part 1</a> and <a href="https://www.youtube.com/watch?v=14yUT5pdyBk&list=PLY1Ks8JEfJR5H6LMgs6EJ_SYcDf3IZsjd&index=4" target="_blank">Solace Java Samples Part 2</a></p>
</aside>
<h2 is-upgraded>Shutdown the RDP</h2>
<aside class="warning"><p>Using PubSub+ Manager, CLI, or SEMP: shutdown or disable the RDP to prevent parallel flows from occuring.</p>
</aside>
<h2 is-upgraded>Make a Replier App</h2>
<p>Take a look at the <a href="https://github.com/SolaceSamples/solace-samples-java/blob/master/src/main/java/com/solace/samples/BasicReplier.java" target="_blank">Basic Replier (source code)</a> sample application.  We are going to modify it slightly.</p>
<ol type="1">
<li>Change the topic subscription from <code>tutorial/requests</code> to <code>GET/&gt;</code>, approximately line 50. (Could be any REST verb, using wildcards or not)</li>
<li>Inside the <code>onReceive()</code> callback method (approximately line 75), replace the line <code>reply.setText(text);</code> with the following, for something more interesting/dynamic:<pre><code>try {
    reply.setText(&#34;Your path was: &#34;+request.getProperties().getString(&#34;JMS_Solace_HTTP_target_path_query_verbatim&#34;));
} catch (Exception e) {
    reply.setText(text);
}
</code></pre>
</li>
<li>Just after the new <code>try { }</code> block, before the reply message is sent as a response to the request, add the following lines:<pre><code>System.out.println(request.dump());  // prints the request message to the console
reply.setApplicationMessageId(request.getApplicationMessageId());  // needed for correlation
</code></pre>
</li>
<li>Run the application, and pass in the required arguments: <code>hostname username@vpn-name [password]</code>.  E.g.:<pre><code>BasicReplier localhost default@default
</code></pre>
</li>
<li>Resubmit the original REST GET request, and you should see following printed to the console of the BasicReplier app:<pre><code>BasicReplier initializing...
Jan 27, 2020 6:22:00 PM com.solacesystems.jcsmp.protocol.impl.TcpClientChannel call
INFO: Connecting to host &#39;orig=localhost, host=localhost&#39; (host 1 of 1, smfclient 2, attempt 1 of 1, this_host_attempt: 1 of 1)
Jan 27, 2020 6:22:01 PM com.solacesystems.jcsmp.protocol.impl.TcpClientChannel call
INFO: Connected to host &#39;orig=localhost, host=localhost&#39; (smfclient 2)
Listening for request messages on topic GET/&gt; ... Press enter to exit
Received request, generating response
Destination:                            Topic &#39;GET/get&#39;
AppMessageID:                           ID:Solace-d2dc2510dbfe295a
Priority:                               0
Class Of Service:                       USER_COS_1
DeliveryMode:                           DIRECT
Message Id:                             7
ReplyTo:                                Topic &#39;#P2P/v:aa-local-broke/#rest-e135cb328ef67649/GET/get&#39;
TimeToLive:                             30000
User Property Map:                      4 entries
  Key &#39;JMS_Solace_HTTP_field_Accept&#39; (String): */*
  Key &#39;JMS_Solace_HTTP_field_User-Agent&#39; (String): curl/7.58.0
  Key &#39;JMS_Solace_HTTP_method&#39; (String): GET
  Key &#39;JMS_Solace_HTTP_target_path_query_verbatim&#39; (String): get?hello=world&amp;solace=cool
</code></pre>
</li>
<li>And at the end of the cURL console, you should see the returned payload of &#34;Sample response&#34;:<pre><code>&gt; curl -u default:default http://localhost:9000/test -v
*   Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to localhost (127.0.0.1) port 9000 (#0)
* Server auth using Basic with user &#39;default&#39;
&gt; GET /test HTTP/1.1
&gt; Host: localhost:9000
&gt; Authorization: Basic ZGVmYXVsdDpkZWZhdWx0
&gt; User-Agent: curl/7.58.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; Content-Length: 15
&lt; Solace-Client-Name: #rest-55e4631320167e61
&lt; Solace-Message-ID: ID:Solace-bf11a8964cec2d0e
&lt;
* Connection #0 to host localhost left intact
Your path was: get?hello=world&amp;solace=cool              &lt;----
</code></pre>
</li>
</ol>
<aside class="special"><p>Success!!</p>
</aside>
<h2 is-upgraded>HTTP Response Codes</h2>
<ol type="1">
<li>For more advanced HTTP response codes, add the following to the sample code, just before the reply message is sent:<pre><code>SDTMap props = JCSMPFactory.onlyInstance().createMap();
try {
    props.putShort(&#34;JMS_Solace_HTTP_status_code&#34;,(short)403);
    props.putString(&#34;JMS_Solace_HTTP_reason_phrase&#34;,&#34;declined&#34;);
} catch (SDTException e) {
    // won&#39;t happen here
    e.printStackTrace();
}
reply.setProperties(props);
</code></pre>
</li>
<li>Restart the Basic Replier, resubmit the REST GET request, and you should see something that looks the following:<pre><code>$ curl -u default:default http://localhost:9000/test -v
*   Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to localhost (127.0.0.1) port 9000 (#0)
* Server auth using Basic with user &#39;default&#39;
&gt; GET /test HTTP/1.1
&gt; Host: localhost:9000
&gt; Authorization: Basic ZGVmYXVsdDpkZWZhdWx0
&gt; User-Agent: curl/7.58.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 403 declined                               &lt;----
&lt; Content-Length: 15
&lt; Solace-Client-Name: #rest-e135cb328ef67649
&lt; Solace-Message-ID: ID:Solace-d2dc2510dbfe295a
&lt;
* Connection #0 to host localhost left intact
Your path was: get?hello=world&amp;solace=cool
</code></pre>
</li>
</ol>
<aside class="special"><p>Great Success!!</p>
</aside>
<h2 is-upgraded>Shared Subscriptions</h2>
<p>One very useful feature of Solace for this type backend service is <strong>Shared Subscriptions</strong>.  It allows multiple applications to all subscribe to the same subscription <em>group</em>, and the Solace broker will round-robin deliver the incoming request/message to only one of the consumers within the group.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Conclusion, Discussion, Best Practices, Links" duration="0">
        <p>Thanks for making it this far! :-D</p>
<h2 class="checklist" is-upgraded>What we&#39;ve covered</h2>
<ul class="checklist">
<li>Configured the Solace broker to act as a REST proxy</li>
<li>Snooped the messages as they have gone through Solace</li>
<li>Built a messaging application to replace/extend/complement the functionality of the REST endpoint</li>
</ul>
<h2 is-upgraded>Some Thoughts</h2>
<ul>
<li>RDPs can be bound to more than one queue.</li>
<li>Good practice to have different types of requests (e.g. GET, POST) go to different queues... then they can be serviced differently by more/less consumer threads/connections for differing levels of service.</li>
<li>Create a 2nd queue, RDP, and REST Conusmer to have two copies of the REST request getting sent out. Cheap/lazy/easy way for added redundancy.</li>
<li>The replacement messging application can either use Direct messaging (like it did in this tutorial), or Guaranteed messaging by using a queue.</li>
<li>The <a href="https://docs.solace.com/PubSub-Basics/Direct-Messages.htm#Shared" target="_blank">Shared Subscriptions feature</a> might be useful for application redundancy / load-balancing, if using Direct messaging.</li>
</ul>
<h2 is-upgraded>Useful Links</h2>
<p><a href="https://docs.solace.com/RESTMessagingPrtl/Solace-REST-Message-Encoding.htm#_Ref393979969" target="_blank">Solace REST Message Encoding</a></p>
<p><a href="https://docs.solace.com/PubSub-ConceptMaps/Component-Maps.htm#REST2" target="_blank">Solace REST Component Map</a></p>
<p><a href="https://docs.solace.com/PubSub-Basics/Wildcard-Charaters-Topic-Subs.htm" target="_blank">All about Solace Wildcards</a></p>
<p><a href="https://docs.solace.com/Overviews/REST-Messaging-Concepts/Multi-Protocol-Integration.htm" target="_blank">Solace REST Multi-Protocol Integration</a></p>
<p><a href="https://docs.solace.com/RESTMessagingPrtl/Solace-REST-Message-Encoding.htm#2.2.6.1" target="_blank">Solace REST Message Correlation</a></p>
<h3 is-upgraded>Thanks!</h3>
<p>Thanks for reading my tutorial!  Aaron@Solace</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>

</body>
</html>
